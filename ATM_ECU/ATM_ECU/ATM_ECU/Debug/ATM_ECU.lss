
ATM_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f0a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000094  00800060  00000f0a  00000f9e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000009  008000f4  008000f4  00001032  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001032  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001064  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000208  00000000  00000000  000010a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000024c8  00000000  00000000  000012a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c95  00000000  00000000  00003770  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000156f  00000000  00000000  00004405  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003e0  00000000  00000000  00005974  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ac7  00000000  00000000  00005d54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000e81  00000000  00000000  0000681b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  0000769c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e0       	ldi	r30, 0x0A	; 10
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 3f       	cpi	r26, 0xF4	; 244
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a4 ef       	ldi	r26, 0xF4	; 244
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ad 3f       	cpi	r26, 0xFD	; 253
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 1c 04 	call	0x838	; 0x838 <main>
  8a:	0c 94 83 07 	jmp	0xf06	; 0xf06 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <APP_init>:

/** INITIALIZATION FUNCTION **/
void APP_init()
{
	//Button_init(BUTTON1_PORT , BUTTON1_PIN); /** ZERO/SET BUTTON **/
	Button_init(BUTTON2_PORT , BUTTON2_PIN); /** START TRIGGER FROM CARD ECU **/
  92:	60 e0       	ldi	r22, 0x00	; 0
  94:	80 e0       	ldi	r24, 0x00	; 0
  96:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <Button_init>
	
	BUZZ_init(); /** ALARM INITIALIZATION **/
  9a:	0e 94 04 02 	call	0x408	; 0x408 <BUZZ_init>
	BUZZ_off();  /** ALARM IS OFF **/
  9e:	0e 94 10 02 	call	0x420	; 0x420 <BUZZ_off>
	
	DIO_setpindir(DIO_PORTB , DIO_PIN0 , DIO_PIN_OUTPUT); /** TRIGGER PIN TO START COMMUNICATION **/
  a2:	41 e0       	ldi	r20, 0x01	; 1
  a4:	60 e0       	ldi	r22, 0x00	; 0
  a6:	81 e0       	ldi	r24, 0x01	; 1
  a8:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	DIO_setpinvalue(DIO_PORTB , DIO_PIN0 , DIO_PIN_LOW);  /** INITIAL VALUE IS ZERO **/
  ac:	40 e0       	ldi	r20, 0x00	; 0
  ae:	60 e0       	ldi	r22, 0x00	; 0
  b0:	81 e0       	ldi	r24, 0x01	; 1
  b2:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	
	TMR0_init(); /** TIMER 0 INITIALIZATION **/
  b6:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <TMR0_init>
	
	SPI_initslave(); /** INITIALIZE SPI MASTER **/
  ba:	0e 94 9d 05 	call	0xb3a	; 0xb3a <SPI_initslave>
	
	KEYPAD_init(); /** INITIALIZE THE KEYPAD **/
  be:	0e 94 16 02 	call	0x42c	; 0x42c <KEYPAD_init>
	
	LCD_init();  /** INITIALIZE LCD **/
  c2:	0e 94 69 03 	call	0x6d2	; 0x6d2 <LCD_init>
	TMR0_delayms(20); /** SET DELAY FOR LCD INITILIZATION **/
  c6:	64 e1       	ldi	r22, 0x14	; 20
  c8:	70 e0       	ldi	r23, 0x00	; 0
  ca:	80 e0       	ldi	r24, 0x00	; 0
  cc:	90 e0       	ldi	r25, 0x00	; 0
  ce:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	LCD_writestr(" WELCOME TO ATM !"); /** DISPLAY WELCOME MESSAGE FOR 1 SEC **/
  d2:	80 e8       	ldi	r24, 0x80	; 128
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <LCD_writestr>
	TMR0_delayms(500);
  da:	64 ef       	ldi	r22, 0xF4	; 244
  dc:	71 e0       	ldi	r23, 0x01	; 1
  de:	80 e0       	ldi	r24, 0x00	; 0
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	LCD_sendcmd(LCD_CLEAR);
  e6:	81 e0       	ldi	r24, 0x01	; 1
  e8:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
	TMR0_delayms(20);
  ec:	64 e1       	ldi	r22, 0x14	; 20
  ee:	70 e0       	ldi	r23, 0x00	; 0
  f0:	80 e0       	ldi	r24, 0x00	; 0
  f2:	90 e0       	ldi	r25, 0x00	; 0
  f4:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	LCD_goto(0 ,1);
  f8:	61 e0       	ldi	r22, 0x01	; 1
  fa:	80 e0       	ldi	r24, 0x00	; 0
  fc:	0e 94 04 04 	call	0x808	; 0x808 <LCD_goto>
	LCD_writestr("Insert A Card"); /** ASK USER TO INSERT HIS CARD **/
 100:	82 e9       	ldi	r24, 0x92	; 146
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <LCD_writestr>
	
	do  /** WAIT FOR THE CARD ECU TRIGGER **/
	{
		Is_pressed(BUTTON2_PORT , BUTTON2_PIN , &triggerstatus);
 108:	44 ef       	ldi	r20, 0xF4	; 244
 10a:	50 e0       	ldi	r21, 0x00	; 0
 10c:	60 e0       	ldi	r22, 0x00	; 0
 10e:	80 e0       	ldi	r24, 0x00	; 0
 110:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Is_pressed>
	} while (triggerstatus == 0);
 114:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <__data_end>
 118:	88 23       	and	r24, r24
 11a:	b1 f3       	breq	.-20     	; 0x108 <APP_init+0x76>
	
	/** WAIT UNTILL TRIGGER ACTION FROM THE CARD ECU **/
	LCD_sendcmd(LCD_CLEAR); /** CLEAR THE LCD **/
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
	TMR0_delayms(20);
 122:	64 e1       	ldi	r22, 0x14	; 20
 124:	70 e0       	ldi	r23, 0x00	; 0
 126:	80 e0       	ldi	r24, 0x00	; 0
 128:	90 e0       	ldi	r25, 0x00	; 0
 12a:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
 12e:	08 95       	ret

00000130 <APP_readuserpin>:
}

/** FUNCTION TO READ USER PIN **/
void APP_readuserpin()
{
	LCD_sendcmd(LCD_CLEAR); /** CLEAR THE LCD **/
 130:	81 e0       	ldi	r24, 0x01	; 1
 132:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
	TMR0_delayms(20);
 136:	64 e1       	ldi	r22, 0x14	; 20
 138:	70 e0       	ldi	r23, 0x00	; 0
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	LCD_goto(0 , 1);
 142:	61 e0       	ldi	r22, 0x01	; 1
 144:	80 e0       	ldi	r24, 0x00	; 0
 146:	0e 94 04 04 	call	0x808	; 0x808 <LCD_goto>
	LCD_writestr("Enter Your PIN"); /** SAK USER TO INSERT CARD PIN **/
 14a:	80 ea       	ldi	r24, 0xA0	; 160
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <LCD_writestr>
	
	for(counter = 0 ; counter < 4 ; counter++)
 152:	10 92 fc 00 	sts	0x00FC, r1	; 0x8000fc <counter>
 156:	24 c0       	rjmp	.+72     	; 0x1a0 <APP_readuserpin+0x70>
	{
		while ((KEYPAD_read(&u8_a_pressednum) == KEYPAD_readFail)); /** POLLING UNTILL NUMBER PRESSED **/
 158:	87 ef       	ldi	r24, 0xF7	; 247
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	0e 94 5e 02 	call	0x4bc	; 0x4bc <KEYPAD_read>
 160:	81 30       	cpi	r24, 0x01	; 1
 162:	d1 f3       	breq	.-12     	; 0x158 <APP_readuserpin+0x28>
		
		LCD_goto(1 , counter); /** DISPLAY * WITH EACH PRESSED NUMBER **/
 164:	60 91 fc 00 	lds	r22, 0x00FC	; 0x8000fc <counter>
 168:	81 e0       	ldi	r24, 0x01	; 1
 16a:	0e 94 04 04 	call	0x808	; 0x808 <LCD_goto>
		LCD_writechar('*');
 16e:	8a e2       	ldi	r24, 0x2A	; 42
 170:	0e 94 aa 03 	call	0x754	; 0x754 <LCD_writechar>
		
		u8_g_userpin[counter] = u8_a_pressednum ; /** STORE THE PRESSED NUMBER **/
 174:	e0 91 fc 00 	lds	r30, 0x00FC	; 0x8000fc <counter>
 178:	f0 e0       	ldi	r31, 0x00	; 0
 17a:	ee 59       	subi	r30, 0x9E	; 158
 17c:	ff 4f       	sbci	r31, 0xFF	; 255
 17e:	80 91 f7 00 	lds	r24, 0x00F7	; 0x8000f7 <u8_a_pressednum>
 182:	80 83       	st	Z, r24
		TMR0_delayms(200);
 184:	68 ec       	ldi	r22, 0xC8	; 200
 186:	70 e0       	ldi	r23, 0x00	; 0
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		
		u8_returnstatus = KEYPAD_readFail; /** REINITIALIZE STATE TO ACCEPT NEW NUMBER **/
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <u8_returnstatus>
	TMR0_delayms(20);
	
	LCD_goto(0 , 1);
	LCD_writestr("Enter Your PIN"); /** SAK USER TO INSERT CARD PIN **/
	
	for(counter = 0 ; counter < 4 ; counter++)
 196:	80 91 fc 00 	lds	r24, 0x00FC	; 0x8000fc <counter>
 19a:	8f 5f       	subi	r24, 0xFF	; 255
 19c:	80 93 fc 00 	sts	0x00FC, r24	; 0x8000fc <counter>
 1a0:	80 91 fc 00 	lds	r24, 0x00FC	; 0x8000fc <counter>
 1a4:	84 30       	cpi	r24, 0x04	; 4
 1a6:	c0 f2       	brcs	.-80     	; 0x158 <APP_readuserpin+0x28>
		u8_returnstatus = KEYPAD_readFail; /** REINITIALIZE STATE TO ACCEPT NEW NUMBER **/
	}
	
	do /** LONG PRESS FOR 2 SECONDS ON ZERO **/
	{
		KEYPAD_read(&status); /** READ THE ZERO FROM KEYPAD **/
 1a8:	86 ef       	ldi	r24, 0xF6	; 246
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	0e 94 5e 02 	call	0x4bc	; 0x4bc <KEYPAD_read>
		TMR0_delayms(1000);   /** DELAY FOR 2000 SECONDS    **/
 1b0:	68 ee       	ldi	r22, 0xE8	; 232
 1b2:	73 e0       	ldi	r23, 0x03	; 3
 1b4:	80 e0       	ldi	r24, 0x00	; 0
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		KEYPAD_read(&status); /** READ THE ZERO FROM KEYPAD **/
 1bc:	86 ef       	ldi	r24, 0xF6	; 246
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	0e 94 5e 02 	call	0x4bc	; 0x4bc <KEYPAD_read>
		
	} while (status != '0');
 1c4:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <status>
 1c8:	80 33       	cpi	r24, 0x30	; 48
 1ca:	71 f7       	brne	.-36     	; 0x1a8 <APP_readuserpin+0x78>
	
}
 1cc:	08 95       	ret

000001ce <APP_startcardcomm>:

/** FUNCTION TO COMMUNICATE WITH CARD ECU TO GET PIN/PAN **/
void APP_startcardcomm()
{
	/** INITIATE COMMUNICATION BETWEEN THE CARD ECU VIA TRIGGER ACTION **/
	DIO_setpinvalue(DIO_PORTB , DIO_PIN0 , DIO_PIN_HIGH);
 1ce:	41 e0       	ldi	r20, 0x01	; 1
 1d0:	60 e0       	ldi	r22, 0x00	; 0
 1d2:	81 e0       	ldi	r24, 0x01	; 1
 1d4:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	
	SPI_receivestring(&u8_g_cardpin); /** RECEIVE THE PIN **/
 1d8:	8b e7       	ldi	r24, 0x7B	; 123
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	0e 94 c4 05 	call	0xb88	; 0xb88 <SPI_receivestring>
	TMR0_delayms(30);
 1e0:	6e e1       	ldi	r22, 0x1E	; 30
 1e2:	70 e0       	ldi	r23, 0x00	; 0
 1e4:	80 e0       	ldi	r24, 0x00	; 0
 1e6:	90 e0       	ldi	r25, 0x00	; 0
 1e8:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	SPI_receivestring(&u8_g_cardpan); /** RECEIVE THE PAN **/
 1ec:	87 e6       	ldi	r24, 0x67	; 103
 1ee:	90 e0       	ldi	r25, 0x00	; 0
 1f0:	0e 94 c4 05 	call	0xb88	; 0xb88 <SPI_receivestring>
	
	/** VERIFY THE USER INSERTED PIN **/
	u8_a_pinnotmatched = 1 ;
 1f4:	81 e0       	ldi	r24, 0x01	; 1
 1f6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	while (u8_a_pintry <= 1 && u8_a_pinnotmatched != 0  ) /** CHECK PIN MATCHING FOR TWO TIMES **/
 1fa:	45 c0       	rjmp	.+138    	; 0x286 <APP_startcardcomm+0xb8>
	{
		u8_a_pinnotmatched = strcmp(u8_g_cardpin , u8_g_userpin); /** COMPARE THE TWO PINs **/
 1fc:	62 e6       	ldi	r22, 0x62	; 98
 1fe:	70 e0       	ldi	r23, 0x00	; 0
 200:	8b e7       	ldi	r24, 0x7B	; 123
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	0e 94 7a 07 	call	0xef4	; 0xef4 <strcmp>
 208:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		
		if (u8_a_pinnotmatched == 0) /** PIN MATCHED **/
 20c:	88 23       	and	r24, r24
 20e:	09 f4       	brne	.+2      	; 0x212 <APP_startcardcomm+0x44>
 210:	42 c0       	rjmp	.+132    	; 0x296 <APP_startcardcomm+0xc8>
			break ;
		}
		
		else /** PIN NOT MATCHED **/
		{
			LCD_sendcmd(LCD_CLEAR); /** CLEAR THE LCD **/
 212:	81 e0       	ldi	r24, 0x01	; 1
 214:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
			TMR0_delayms(20);
 218:	64 e1       	ldi	r22, 0x14	; 20
 21a:	70 e0       	ldi	r23, 0x00	; 0
 21c:	80 e0       	ldi	r24, 0x00	; 0
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
			
			LCD_goto(0,0);
 224:	60 e0       	ldi	r22, 0x00	; 0
 226:	80 e0       	ldi	r24, 0x00	; 0
 228:	0e 94 04 04 	call	0x808	; 0x808 <LCD_goto>
			LCD_writestr("PIN NOT MATCHED !"); /** DISPLAY MESSAGE FOR 1 SEC **/
 22c:	8f ea       	ldi	r24, 0xAF	; 175
 22e:	90 e0       	ldi	r25, 0x00	; 0
 230:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <LCD_writestr>
			TMR0_delayms(500);
 234:	64 ef       	ldi	r22, 0xF4	; 244
 236:	71 e0       	ldi	r23, 0x01	; 1
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
			
			LCD_sendcmd(LCD_CLEAR); /** CLEAR THE LCD **/
 240:	81 e0       	ldi	r24, 0x01	; 1
 242:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
			TMR0_delayms(20);
 246:	64 e1       	ldi	r22, 0x14	; 20
 248:	70 e0       	ldi	r23, 0x00	; 0
 24a:	80 e0       	ldi	r24, 0x00	; 0
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
			
			APP_readuserpin(); /** READ THE PIN AGAIN **/
 252:	0e 94 98 00 	call	0x130	; 0x130 <APP_readuserpin>
		}
		
		u8_a_pintry++ ; /** TRY FOR MORE ATTEMPT **/
 256:	80 91 f5 00 	lds	r24, 0x00F5	; 0x8000f5 <u8_a_pintry>
 25a:	8f 5f       	subi	r24, 0xFF	; 255
 25c:	80 93 f5 00 	sts	0x00F5, r24	; 0x8000f5 <u8_a_pintry>
		
		if (u8_a_pintry > 1)
 260:	82 30       	cpi	r24, 0x02	; 2
 262:	88 f0       	brcs	.+34     	; 0x286 <APP_startcardcomm+0xb8>
		{
			while (1)
			{
				BUZZ_on();
 264:	0e 94 0a 02 	call	0x414	; 0x414 <BUZZ_on>
				TMR0_delayms(500);
 268:	64 ef       	ldi	r22, 0xF4	; 244
 26a:	71 e0       	ldi	r23, 0x01	; 1
 26c:	80 e0       	ldi	r24, 0x00	; 0
 26e:	90 e0       	ldi	r25, 0x00	; 0
 270:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
				
				BUZZ_off();
 274:	0e 94 10 02 	call	0x420	; 0x420 <BUZZ_off>
				TMR0_delayms(500);
 278:	64 ef       	ldi	r22, 0xF4	; 244
 27a:	71 e0       	ldi	r23, 0x01	; 1
 27c:	80 e0       	ldi	r24, 0x00	; 0
 27e:	90 e0       	ldi	r25, 0x00	; 0
 280:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
 284:	ef cf       	rjmp	.-34     	; 0x264 <APP_startcardcomm+0x96>
	
	SPI_receivestring(&u8_g_cardpan); /** RECEIVE THE PAN **/
	
	/** VERIFY THE USER INSERTED PIN **/
	u8_a_pinnotmatched = 1 ;
	while (u8_a_pintry <= 1 && u8_a_pinnotmatched != 0  ) /** CHECK PIN MATCHING FOR TWO TIMES **/
 286:	80 91 f5 00 	lds	r24, 0x00F5	; 0x8000f5 <u8_a_pintry>
 28a:	82 30       	cpi	r24, 0x02	; 2
 28c:	20 f4       	brcc	.+8      	; 0x296 <APP_startcardcomm+0xc8>
 28e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 292:	81 11       	cpse	r24, r1
 294:	b3 cf       	rjmp	.-154    	; 0x1fc <APP_startcardcomm+0x2e>
 296:	08 95       	ret

00000298 <APP_getamount>:
}


/** FUNCTION TO GET THE AMOUNT OF MONEY NEEDED **/
void APP_getamount()
{
 298:	0f 93       	push	r16
 29a:	1f 93       	push	r17
 29c:	cf 93       	push	r28
 29e:	df 93       	push	r29
	uint16_t u16_l_amout = 0 , u8_a_pos = 1000 ;
	
	LCD_sendcmd(LCD_CLEAR); /** CLEAR THE LCD **/
 2a0:	81 e0       	ldi	r24, 0x01	; 1
 2a2:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
	TMR0_delayms(20);
 2a6:	64 e1       	ldi	r22, 0x14	; 20
 2a8:	70 e0       	ldi	r23, 0x00	; 0
 2aa:	80 e0       	ldi	r24, 0x00	; 0
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	LCD_writestr("ENTER THE AMOUNT"); /** ASK USER TO ENTER THE AMOUNT NEEDED **/
 2b2:	81 ec       	ldi	r24, 0xC1	; 193
 2b4:	90 e0       	ldi	r25, 0x00	; 0
 2b6:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <LCD_writestr>
	TMR0_delayms(200);
 2ba:	68 ec       	ldi	r22, 0xC8	; 200
 2bc:	70 e0       	ldi	r23, 0x00	; 0
 2be:	80 e0       	ldi	r24, 0x00	; 0
 2c0:	90 e0       	ldi	r25, 0x00	; 0
 2c2:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	LCD_goto(1,2);
 2c6:	62 e0       	ldi	r22, 0x02	; 2
 2c8:	81 e0       	ldi	r24, 0x01	; 1
 2ca:	0e 94 04 04 	call	0x808	; 0x808 <LCD_goto>

	for(counter = 0 ; counter <= 6 ; counter++)
 2ce:	10 92 fc 00 	sts	0x00FC, r1	; 0x8000fc <counter>


/** FUNCTION TO GET THE AMOUNT OF MONEY NEEDED **/
void APP_getamount()
{
	uint16_t u16_l_amout = 0 , u8_a_pos = 1000 ;
 2d2:	c8 ee       	ldi	r28, 0xE8	; 232
 2d4:	d3 e0       	ldi	r29, 0x03	; 3
 2d6:	00 e0       	ldi	r16, 0x00	; 0
 2d8:	10 e0       	ldi	r17, 0x00	; 0
	LCD_writestr("ENTER THE AMOUNT"); /** ASK USER TO ENTER THE AMOUNT NEEDED **/
	TMR0_delayms(200);
	
	LCD_goto(1,2);

	for(counter = 0 ; counter <= 6 ; counter++)
 2da:	41 c0       	rjmp	.+130    	; 0x35e <APP_getamount+0xc6>
	{
		u8_a_pressednum = KEYPAD_readFail ;
 2dc:	91 e0       	ldi	r25, 0x01	; 1
 2de:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <u8_a_pressednum>
		
		if (counter == 4)
 2e2:	84 30       	cpi	r24, 0x04	; 4
 2e4:	39 f4       	brne	.+14     	; 0x2f4 <APP_getamount+0x5c>
		{
			LCD_writechar('.'); /** DECIMEL POINT **/
 2e6:	8e e2       	ldi	r24, 0x2E	; 46
 2e8:	0e 94 aa 03 	call	0x754	; 0x754 <LCD_writechar>
			u8_returnstatus = KEYPAD_readFail; /** REINITIALIZE STATE TO ACCEPT NEW NUMBER **/
 2ec:	81 e0       	ldi	r24, 0x01	; 1
 2ee:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <u8_returnstatus>
			continue ;
 2f2:	30 c0       	rjmp	.+96     	; 0x354 <APP_getamount+0xbc>
		}
		
		while ((KEYPAD_read(&u8_a_pressednum) == KEYPAD_readFail)); /** POLLING UNTILL NUMBER PRESSED **/
 2f4:	87 ef       	ldi	r24, 0xF7	; 247
 2f6:	90 e0       	ldi	r25, 0x00	; 0
 2f8:	0e 94 5e 02 	call	0x4bc	; 0x4bc <KEYPAD_read>
 2fc:	81 30       	cpi	r24, 0x01	; 1
 2fe:	d1 f3       	breq	.-12     	; 0x2f4 <APP_getamount+0x5c>
		
		TMR0_delayms(200);
 300:	68 ec       	ldi	r22, 0xC8	; 200
 302:	70 e0       	ldi	r23, 0x00	; 0
 304:	80 e0       	ldi	r24, 0x00	; 0
 306:	90 e0       	ldi	r25, 0x00	; 0
 308:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		LCD_writechar(u8_a_pressednum);
 30c:	80 91 f7 00 	lds	r24, 0x00F7	; 0x8000f7 <u8_a_pressednum>
 310:	0e 94 aa 03 	call	0x754	; 0x754 <LCD_writechar>
		
		if (counter < 4)
 314:	80 91 fc 00 	lds	r24, 0x00FC	; 0x8000fc <counter>
 318:	84 30       	cpi	r24, 0x04	; 4
 31a:	c8 f4       	brcc	.+50     	; 0x34e <APP_getamount+0xb6>
		{
			u16_l_amout += (u8_a_pressednum - 48) * u8_a_pos ; /** CHARACTER TO INTEGER **/
 31c:	80 91 f7 00 	lds	r24, 0x00F7	; 0x8000f7 <u8_a_pressednum>
 320:	90 e0       	ldi	r25, 0x00	; 0
 322:	c0 97       	sbiw	r24, 0x30	; 48
 324:	8c 9f       	mul	r24, r28
 326:	90 01       	movw	r18, r0
 328:	8d 9f       	mul	r24, r29
 32a:	30 0d       	add	r19, r0
 32c:	9c 9f       	mul	r25, r28
 32e:	30 0d       	add	r19, r0
 330:	11 24       	eor	r1, r1
 332:	02 0f       	add	r16, r18
 334:	13 1f       	adc	r17, r19
			u8_a_pos /= 10 ; /** GO TO THE NEXT POSITION **/
 336:	9e 01       	movw	r18, r28
 338:	ad ec       	ldi	r26, 0xCD	; 205
 33a:	bc ec       	ldi	r27, 0xCC	; 204
 33c:	0e 94 6b 07 	call	0xed6	; 0xed6 <__umulhisi3>
 340:	ec 01       	movw	r28, r24
 342:	d6 95       	lsr	r29
 344:	c7 95       	ror	r28
 346:	d6 95       	lsr	r29
 348:	c7 95       	ror	r28
 34a:	d6 95       	lsr	r29
 34c:	c7 95       	ror	r28
		}
		
		u8_returnstatus = KEYPAD_readFail; /** REINITIALIZE STATE TO ACCEPT NEW NUMBER **/
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <u8_returnstatus>
	LCD_writestr("ENTER THE AMOUNT"); /** ASK USER TO ENTER THE AMOUNT NEEDED **/
	TMR0_delayms(200);
	
	LCD_goto(1,2);

	for(counter = 0 ; counter <= 6 ; counter++)
 354:	80 91 fc 00 	lds	r24, 0x00FC	; 0x8000fc <counter>
 358:	8f 5f       	subi	r24, 0xFF	; 255
 35a:	80 93 fc 00 	sts	0x00FC, r24	; 0x8000fc <counter>
 35e:	80 91 fc 00 	lds	r24, 0x00FC	; 0x8000fc <counter>
 362:	87 30       	cpi	r24, 0x07	; 7
 364:	08 f4       	brcc	.+2      	; 0x368 <APP_getamount+0xd0>
 366:	ba cf       	rjmp	.-140    	; 0x2dc <APP_getamount+0x44>
		}
		
		u8_returnstatus = KEYPAD_readFail; /** REINITIALIZE STATE TO ACCEPT NEW NUMBER **/
	}
	
	TMR0_delayms(100);
 368:	64 e6       	ldi	r22, 0x64	; 100
 36a:	70 e0       	ldi	r23, 0x00	; 0
 36c:	80 e0       	ldi	r24, 0x00	; 0
 36e:	90 e0       	ldi	r25, 0x00	; 0
 370:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	if (u16_l_amout > 5000)
 374:	09 38       	cpi	r16, 0x89	; 137
 376:	13 41       	sbci	r17, 0x13	; 19
 378:	f8 f0       	brcs	.+62     	; 0x3b8 <APP_getamount+0x120>
	{
		LCD_sendcmd(LCD_CLEAR);
 37a:	81 e0       	ldi	r24, 0x01	; 1
 37c:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		TMR0_delayms(20);
 380:	64 e1       	ldi	r22, 0x14	; 20
 382:	70 e0       	ldi	r23, 0x00	; 0
 384:	80 e0       	ldi	r24, 0x00	; 0
 386:	90 e0       	ldi	r25, 0x00	; 0
 388:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		
		LCD_goto(0 , 0);
 38c:	60 e0       	ldi	r22, 0x00	; 0
 38e:	80 e0       	ldi	r24, 0x00	; 0
 390:	0e 94 04 04 	call	0x808	; 0x808 <LCD_goto>
		LCD_writestr("MAX TRANSACTION ");
 394:	82 ed       	ldi	r24, 0xD2	; 210
 396:	90 e0       	ldi	r25, 0x00	; 0
 398:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <LCD_writestr>
		
		LCD_goto(1 , 0);
 39c:	60 e0       	ldi	r22, 0x00	; 0
 39e:	81 e0       	ldi	r24, 0x01	; 1
 3a0:	0e 94 04 04 	call	0x808	; 0x808 <LCD_goto>
		LCD_writestr("AMOUNT EXCEEDED");
 3a4:	83 ee       	ldi	r24, 0xE3	; 227
 3a6:	90 e0       	ldi	r25, 0x00	; 0
 3a8:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <LCD_writestr>
		
		TMR0_delayms(1000);
 3ac:	68 ee       	ldi	r22, 0xE8	; 232
 3ae:	73 e0       	ldi	r23, 0x03	; 3
 3b0:	80 e0       	ldi	r24, 0x00	; 0
 3b2:	90 e0       	ldi	r25, 0x00	; 0
 3b4:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	}
	
}
 3b8:	df 91       	pop	r29
 3ba:	cf 91       	pop	r28
 3bc:	1f 91       	pop	r17
 3be:	0f 91       	pop	r16
 3c0:	08 95       	ret

000003c2 <Button_init>:
/* RETURN    : void                                              */
/*****************************************************************/
void Button_init(uint8_t Button_port , uint8_t Button_pin)
{
	/** SET THE DIRECTION OF BUTTON AS INPUT **/
	DIO_setpindir(Button_port , Button_pin , DIO_PIN_INPUT);
 3c2:	40 e0       	ldi	r20, 0x00	; 0
 3c4:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
 3c8:	08 95       	ret

000003ca <Is_pressed>:
/* FUNCTION TO CHECK THE BUTTON STATUS PRESSED OR NOT            */
/* ARGUMENTS : TAKES THE BUTTON PIN                              */
/* RETURN    : RETURNS BUTTON_t type                             */
/*****************************************************************/
button_t Is_pressed(uint8_t Button_port , uint8_t Button_pin , uint8_t * value)
{
 3ca:	0f 93       	push	r16
 3cc:	1f 93       	push	r17
 3ce:	cf 93       	push	r28
 3d0:	df 93       	push	r29
 3d2:	1f 92       	push	r1
 3d4:	cd b7       	in	r28, 0x3d	; 61
 3d6:	de b7       	in	r29, 0x3e	; 62
 3d8:	8a 01       	movw	r16, r20
	button_t button_state = Button_Notpressed ; /* VARIABLE TO HOLD THE RETURN TYPE OF THE FUNCTION */
	
	PinRead_t pin_status = NOT_VALID_READ ;  /** VARIABLE TO HOLD THE STATE OF PIN READ **/
	
	uint8_t pvalue = 0 ;
 3da:	19 82       	std	Y+1, r1	; 0x01
	
	pin_status = DIO_readpin(Button_port , Button_pin , &pvalue); /** READ THE BUTTON PIN VALUE */
 3dc:	ae 01       	movw	r20, r28
 3de:	4f 5f       	subi	r20, 0xFF	; 255
 3e0:	5f 4f       	sbci	r21, 0xFF	; 255
 3e2:	0e 94 25 05 	call	0xa4a	; 0xa4a <DIO_readpin>
	
	if (!pin_status) 
 3e6:	81 11       	cpse	r24, r1
 3e8:	05 c0       	rjmp	.+10     	; 0x3f4 <Is_pressed+0x2a>
	{
		button_state = Button_pressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
		*value = pvalue ;
 3ea:	89 81       	ldd	r24, Y+1	; 0x01
 3ec:	f8 01       	movw	r30, r16
 3ee:	80 83       	st	Z, r24
	
	pin_status = DIO_readpin(Button_port , Button_pin , &pvalue); /** READ THE BUTTON PIN VALUE */
	
	if (!pin_status) 
	{
		button_state = Button_pressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
 3f0:	81 e0       	ldi	r24, 0x01	; 1
 3f2:	04 c0       	rjmp	.+8      	; 0x3fc <Is_pressed+0x32>
	}
	
	else
	{
		button_state = Button_Notpressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
		*value = pvalue ;
 3f4:	89 81       	ldd	r24, Y+1	; 0x01
 3f6:	f8 01       	movw	r30, r16
 3f8:	80 83       	st	Z, r24
		*value = pvalue ;
	}
	
	else
	{
		button_state = Button_Notpressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
 3fa:	80 e0       	ldi	r24, 0x00	; 0
		*value = pvalue ;
	}
	
	return button_state ; /** RETURN THE STATUS OF THE BUTTON **/
}
 3fc:	0f 90       	pop	r0
 3fe:	df 91       	pop	r29
 400:	cf 91       	pop	r28
 402:	1f 91       	pop	r17
 404:	0f 91       	pop	r16
 406:	08 95       	ret

00000408 <BUZZ_init>:
/** RETURN     : VOID                                 **/
/*******************************************************/
void BUZZ_init()
{
	/** SET THE DIRECTION OF BUZZER PIN AS OUTPUT **/
	DIO_setpindir(BUZZ_PORT , BUZZ_PIN , DIO_PIN_OUTPUT);
 408:	41 e0       	ldi	r20, 0x01	; 1
 40a:	63 e0       	ldi	r22, 0x03	; 3
 40c:	81 e0       	ldi	r24, 0x01	; 1
 40e:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
 412:	08 95       	ret

00000414 <BUZZ_on>:
/** RETURN     : VOID                                 **/
/*******************************************************/
void BUZZ_on()
{
	/** SET THE BUZZER PIN AS HIGH **/
	DIO_setpinvalue(BUZZ_PORT , BUZZ_PIN , DIO_PIN_HIGH);
 414:	41 e0       	ldi	r20, 0x01	; 1
 416:	63 e0       	ldi	r22, 0x03	; 3
 418:	81 e0       	ldi	r24, 0x01	; 1
 41a:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
 41e:	08 95       	ret

00000420 <BUZZ_off>:
/** RETURN     : VOID                                 **/
/*******************************************************/
void BUZZ_off()
{
	/** SET THE BUZZER PIN AS LOW **/
	DIO_setpinvalue(BUZZ_PORT , BUZZ_PIN , DIO_PIN_LOW);
 420:	40 e0       	ldi	r20, 0x00	; 0
 422:	63 e0       	ldi	r22, 0x03	; 3
 424:	81 e0       	ldi	r24, 0x01	; 1
 426:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
 42a:	08 95       	ret

0000042c <KEYPAD_init>:
/** @return KEYPAD_initFail                                                */
/***************************************************************************/
KEYPAD_initError KEYPAD_init(void)
{
    /*Rows direction initialization*/
    DIO_setpindir(ROW_PORT_DATA, R1 , DIO_PIN_OUTPUT);
 42c:	41 e0       	ldi	r20, 0x01	; 1
 42e:	62 e0       	ldi	r22, 0x02	; 2
 430:	82 e0       	ldi	r24, 0x02	; 2
 432:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	DIO_setpindir(ROW_PORT_DATA, R2 , DIO_PIN_OUTPUT);
 436:	41 e0       	ldi	r20, 0x01	; 1
 438:	63 e0       	ldi	r22, 0x03	; 3
 43a:	82 e0       	ldi	r24, 0x02	; 2
 43c:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	DIO_setpindir(ROW_PORT_DATA, R3 , DIO_PIN_OUTPUT);
 440:	41 e0       	ldi	r20, 0x01	; 1
 442:	64 e0       	ldi	r22, 0x04	; 4
 444:	82 e0       	ldi	r24, 0x02	; 2
 446:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	DIO_setpindir(DIO_PORTD, R4 , DIO_PIN_OUTPUT);
 44a:	41 e0       	ldi	r20, 0x01	; 1
 44c:	60 e0       	ldi	r22, 0x00	; 0
 44e:	83 e0       	ldi	r24, 0x03	; 3
 450:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	
    /*Columns direction initialization*/
	DIO_setpindir(COLUMN_PORT_DATA , C1 , DIO_PIN_INPUT);
 454:	40 e0       	ldi	r20, 0x00	; 0
 456:	65 e0       	ldi	r22, 0x05	; 5
 458:	82 e0       	ldi	r24, 0x02	; 2
 45a:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	DIO_setpindir(COLUMN_PORT_DATA , C2 , DIO_PIN_INPUT);
 45e:	40 e0       	ldi	r20, 0x00	; 0
 460:	66 e0       	ldi	r22, 0x06	; 6
 462:	82 e0       	ldi	r24, 0x02	; 2
 464:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	DIO_setpindir(COLUMN_PORT_DATA , C3 , DIO_PIN_INPUT);
 468:	40 e0       	ldi	r20, 0x00	; 0
 46a:	67 e0       	ldi	r22, 0x07	; 7
 46c:	82 e0       	ldi	r24, 0x02	; 2
 46e:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
	DIO_setpinvalue(DIO_PORTD , R4 ,  DIO_PIN_LOW);
	

    #elif CONNECTION == 'U'
	
	DIO_setpinvalue(ROW_PORT_DATA , R1 , DIO_PIN_HIGH);
 472:	41 e0       	ldi	r20, 0x01	; 1
 474:	62 e0       	ldi	r22, 0x02	; 2
 476:	82 e0       	ldi	r24, 0x02	; 2
 478:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	DIO_setpinvalue(ROW_PORT_DATA , R2 , DIO_PIN_HIGH);
 47c:	41 e0       	ldi	r20, 0x01	; 1
 47e:	63 e0       	ldi	r22, 0x03	; 3
 480:	82 e0       	ldi	r24, 0x02	; 2
 482:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	DIO_setpinvalue(ROW_PORT_DATA , R3 , DIO_PIN_HIGH);
 486:	41 e0       	ldi	r20, 0x01	; 1
 488:	64 e0       	ldi	r22, 0x04	; 4
 48a:	82 e0       	ldi	r24, 0x02	; 2
 48c:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	DIO_setpinvalue(DIO_PORTD , R4 , DIO_PIN_HIGH);
 490:	41 e0       	ldi	r20, 0x01	; 1
 492:	60 e0       	ldi	r22, 0x00	; 0
 494:	83 e0       	ldi	r24, 0x03	; 3
 496:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	
	DIO_setpinvalue(COLUMN_PORT_DATA , C1 , DIO_PIN_HIGH);
 49a:	41 e0       	ldi	r20, 0x01	; 1
 49c:	65 e0       	ldi	r22, 0x05	; 5
 49e:	82 e0       	ldi	r24, 0x02	; 2
 4a0:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	DIO_setpinvalue(COLUMN_PORT_DATA , C2 , DIO_PIN_HIGH);
 4a4:	41 e0       	ldi	r20, 0x01	; 1
 4a6:	66 e0       	ldi	r22, 0x06	; 6
 4a8:	82 e0       	ldi	r24, 0x02	; 2
 4aa:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	DIO_setpinvalue(COLUMN_PORT_DATA , C3 , DIO_PIN_HIGH);
 4ae:	41 e0       	ldi	r20, 0x01	; 1
 4b0:	67 e0       	ldi	r22, 0x07	; 7
 4b2:	82 e0       	ldi	r24, 0x02	; 2
 4b4:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	
    #endif
    return KEYPAD_initSuccess;
}
 4b8:	80 e0       	ldi	r24, 0x00	; 0
 4ba:	08 95       	ret

000004bc <KEYPAD_read>:
/** @param *u8_a_value refrence to store the read value in                 */
/** @return KEYPAD_readSuccess                                             */
/** @return KEYPAD_readFail                                                */
/***************************************************************************/
KEYPAD_readError KEYPAD_read(uint8_t *u8_a_value)
{
 4bc:	ef 92       	push	r14
 4be:	ff 92       	push	r15
 4c0:	0f 93       	push	r16
 4c2:	1f 93       	push	r17
 4c4:	cf 93       	push	r28
 4c6:	df 93       	push	r29
 4c8:	cd b7       	in	r28, 0x3d	; 61
 4ca:	de b7       	in	r29, 0x3e	; 62
 4cc:	27 97       	sbiw	r28, 0x07	; 7
 4ce:	0f b6       	in	r0, 0x3f	; 63
 4d0:	f8 94       	cli
 4d2:	de bf       	out	0x3e, r29	; 62
 4d4:	0f be       	out	0x3f, r0	; 63
 4d6:	cd bf       	out	0x3d, r28	; 61
 4d8:	7c 01       	movw	r14, r24
    #elif CONNECTION == 'D'
    #define u8_l_readCheck DIO_PIN_HIGH
    #define u8_l_pinValue  DIO_PIN_HIGH
    #endif

    uint8_t u8_l_Rows[ROWS_SIZE] = {R1, R2, R3};
 4da:	19 82       	std	Y+1, r1	; 0x01
 4dc:	1a 82       	std	Y+2, r1	; 0x02
 4de:	1b 82       	std	Y+3, r1	; 0x03
 4e0:	1c 82       	std	Y+4, r1	; 0x04
 4e2:	82 e0       	ldi	r24, 0x02	; 2
 4e4:	89 83       	std	Y+1, r24	; 0x01
 4e6:	83 e0       	ldi	r24, 0x03	; 3
 4e8:	8a 83       	std	Y+2, r24	; 0x02
 4ea:	84 e0       	ldi	r24, 0x04	; 4
 4ec:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t u8_l_Columns[COLUMNS_SIZE] = {C1, C2, C3};
 4ee:	85 e0       	ldi	r24, 0x05	; 5
 4f0:	8d 83       	std	Y+5, r24	; 0x05
 4f2:	86 e0       	ldi	r24, 0x06	; 6
 4f4:	8e 83       	std	Y+6, r24	; 0x06
 4f6:	87 e0       	ldi	r24, 0x07	; 7
 4f8:	8f 83       	std	Y+7, r24	; 0x07

    for (u8_a_rowiterator = 0; u8_a_rowiterator < ROWS_SIZE; u8_a_rowiterator++)
 4fa:	00 e0       	ldi	r16, 0x00	; 0
 4fc:	90 c0       	rjmp	.+288    	; 0x61e <KEYPAD_read+0x162>
    {
		if (u8_a_rowiterator == 3 )
 4fe:	03 30       	cpi	r16, 0x03	; 3
 500:	39 f4       	brne	.+14     	; 0x510 <KEYPAD_read+0x54>
		{
			DIO_setpinvalue(DIO_PORTD , DIO_PIN0, u8_l_pinValue);
 502:	40 e0       	ldi	r20, 0x00	; 0
 504:	60 e0       	ldi	r22, 0x00	; 0
 506:	83 e0       	ldi	r24, 0x03	; 3
 508:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
/** @param *u8_a_value refrence to store the read value in                 */
/** @return KEYPAD_readSuccess                                             */
/** @return KEYPAD_readFail                                                */
/***************************************************************************/
KEYPAD_readError KEYPAD_read(uint8_t *u8_a_value)
{
 50c:	10 e0       	ldi	r17, 0x00	; 0
 50e:	72 c0       	rjmp	.+228    	; 0x5f4 <KEYPAD_read+0x138>
		{
			DIO_setpinvalue(DIO_PORTD , DIO_PIN0, u8_l_pinValue);
		}
		else
		{
			DIO_setpinvalue(ROW_PORT_DATA , u8_l_Rows[u8_a_rowiterator] , u8_l_pinValue);
 510:	e1 e0       	ldi	r30, 0x01	; 1
 512:	f0 e0       	ldi	r31, 0x00	; 0
 514:	ec 0f       	add	r30, r28
 516:	fd 1f       	adc	r31, r29
 518:	e0 0f       	add	r30, r16
 51a:	f1 1d       	adc	r31, r1
 51c:	40 e0       	ldi	r20, 0x00	; 0
 51e:	60 81       	ld	r22, Z
 520:	82 e0       	ldi	r24, 0x02	; 2
 522:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
 526:	f2 cf       	rjmp	.-28     	; 0x50c <KEYPAD_read+0x50>
		}

        for (u8_a_coulumniterator = 0; u8_a_coulumniterator < COLUMNS_SIZE; u8_a_coulumniterator++)
        {
            DIO_readpin(COLUMN_PORT_DATA , u8_l_Columns[u8_a_coulumniterator] , u8_a_value);
 528:	e5 e0       	ldi	r30, 0x05	; 5
 52a:	f0 e0       	ldi	r31, 0x00	; 0
 52c:	ec 0f       	add	r30, r28
 52e:	fd 1f       	adc	r31, r29
 530:	e1 0f       	add	r30, r17
 532:	f1 1d       	adc	r31, r1
 534:	a7 01       	movw	r20, r14
 536:	60 81       	ld	r22, Z
 538:	82 e0       	ldi	r24, 0x02	; 2
 53a:	0e 94 25 05 	call	0xa4a	; 0xa4a <DIO_readpin>
            if (*u8_a_value == u8_l_readCheck)
 53e:	f7 01       	movw	r30, r14
 540:	80 81       	ld	r24, Z
 542:	81 11       	cpse	r24, r1
 544:	56 c0       	rjmp	.+172    	; 0x5f2 <KEYPAD_read+0x136>
            {
                if (u8_a_rowiterator == 0)
 546:	01 11       	cpse	r16, r1
 548:	11 c0       	rjmp	.+34     	; 0x56c <KEYPAD_read+0xb0>
                {
                    if (u8_a_coulumniterator == 0)
 54a:	11 11       	cpse	r17, r1
 54c:	03 c0       	rjmp	.+6      	; 0x554 <KEYPAD_read+0x98>
                    {
                        *u8_a_value = '1' ;
 54e:	81 e3       	ldi	r24, 0x31	; 49
 550:	80 83       	st	Z, r24
 552:	3b c0       	rjmp	.+118    	; 0x5ca <KEYPAD_read+0x10e>
                    }
                    else if (u8_a_coulumniterator == 1)
 554:	11 30       	cpi	r17, 0x01	; 1
 556:	21 f4       	brne	.+8      	; 0x560 <KEYPAD_read+0xa4>
                    {
                        *u8_a_value = '2' ;
 558:	82 e3       	ldi	r24, 0x32	; 50
 55a:	f7 01       	movw	r30, r14
 55c:	80 83       	st	Z, r24
 55e:	35 c0       	rjmp	.+106    	; 0x5ca <KEYPAD_read+0x10e>
                    }
                    else if (u8_a_coulumniterator == 2)
 560:	12 30       	cpi	r17, 0x02	; 2
 562:	99 f5       	brne	.+102    	; 0x5ca <KEYPAD_read+0x10e>
                    {
                        *u8_a_value = '3' ;
 564:	83 e3       	ldi	r24, 0x33	; 51
 566:	f7 01       	movw	r30, r14
 568:	80 83       	st	Z, r24
 56a:	2f c0       	rjmp	.+94     	; 0x5ca <KEYPAD_read+0x10e>
                    }
                }

                else if (u8_a_rowiterator == 1)
 56c:	01 30       	cpi	r16, 0x01	; 1
 56e:	91 f4       	brne	.+36     	; 0x594 <KEYPAD_read+0xd8>
                {
                    if (u8_a_coulumniterator == 0)
 570:	11 11       	cpse	r17, r1
 572:	04 c0       	rjmp	.+8      	; 0x57c <KEYPAD_read+0xc0>
                    {
                        *u8_a_value = '4' ;
 574:	84 e3       	ldi	r24, 0x34	; 52
 576:	f7 01       	movw	r30, r14
 578:	80 83       	st	Z, r24
 57a:	27 c0       	rjmp	.+78     	; 0x5ca <KEYPAD_read+0x10e>
                    }
                    else if (u8_a_coulumniterator == 1)
 57c:	11 30       	cpi	r17, 0x01	; 1
 57e:	21 f4       	brne	.+8      	; 0x588 <KEYPAD_read+0xcc>
                    {
                        *u8_a_value = '5' ;
 580:	85 e3       	ldi	r24, 0x35	; 53
 582:	f7 01       	movw	r30, r14
 584:	80 83       	st	Z, r24
 586:	21 c0       	rjmp	.+66     	; 0x5ca <KEYPAD_read+0x10e>
                    }
                    else if (u8_a_coulumniterator == 2)
 588:	12 30       	cpi	r17, 0x02	; 2
 58a:	f9 f4       	brne	.+62     	; 0x5ca <KEYPAD_read+0x10e>
                    {
                        *u8_a_value = '6' ;
 58c:	86 e3       	ldi	r24, 0x36	; 54
 58e:	f7 01       	movw	r30, r14
 590:	80 83       	st	Z, r24
 592:	1b c0       	rjmp	.+54     	; 0x5ca <KEYPAD_read+0x10e>
                    }
                }

                else if (u8_a_rowiterator == 2)
 594:	02 30       	cpi	r16, 0x02	; 2
 596:	91 f4       	brne	.+36     	; 0x5bc <KEYPAD_read+0x100>
                {
                    if (u8_a_coulumniterator == 0)
 598:	11 11       	cpse	r17, r1
 59a:	04 c0       	rjmp	.+8      	; 0x5a4 <KEYPAD_read+0xe8>
                    {
                        *u8_a_value = '7' ;
 59c:	87 e3       	ldi	r24, 0x37	; 55
 59e:	f7 01       	movw	r30, r14
 5a0:	80 83       	st	Z, r24
 5a2:	13 c0       	rjmp	.+38     	; 0x5ca <KEYPAD_read+0x10e>
                    }
                    else if (u8_a_coulumniterator == 1)
 5a4:	11 30       	cpi	r17, 0x01	; 1
 5a6:	21 f4       	brne	.+8      	; 0x5b0 <KEYPAD_read+0xf4>
                    {
                        *u8_a_value = '8' ;
 5a8:	88 e3       	ldi	r24, 0x38	; 56
 5aa:	f7 01       	movw	r30, r14
 5ac:	80 83       	st	Z, r24
 5ae:	0d c0       	rjmp	.+26     	; 0x5ca <KEYPAD_read+0x10e>
                    }
                    else if (u8_a_coulumniterator == 2)
 5b0:	12 30       	cpi	r17, 0x02	; 2
 5b2:	59 f4       	brne	.+22     	; 0x5ca <KEYPAD_read+0x10e>
                    {
                        *u8_a_value = '9' ;
 5b4:	89 e3       	ldi	r24, 0x39	; 57
 5b6:	f7 01       	movw	r30, r14
 5b8:	80 83       	st	Z, r24
 5ba:	07 c0       	rjmp	.+14     	; 0x5ca <KEYPAD_read+0x10e>
                    }
                }
				
				else if (u8_a_rowiterator == 3)
 5bc:	03 30       	cpi	r16, 0x03	; 3
 5be:	29 f4       	brne	.+10     	; 0x5ca <KEYPAD_read+0x10e>
				{
					if (u8_a_coulumniterator == 0)
 5c0:	11 11       	cpse	r17, r1
 5c2:	03 c0       	rjmp	.+6      	; 0x5ca <KEYPAD_read+0x10e>
					{
						*u8_a_value = '0' ;
 5c4:	80 e3       	ldi	r24, 0x30	; 48
 5c6:	f7 01       	movw	r30, r14
 5c8:	80 83       	st	Z, r24
					}
				}
				if (u8_a_rowiterator == 3)
 5ca:	03 30       	cpi	r16, 0x03	; 3
 5cc:	31 f4       	brne	.+12     	; 0x5da <KEYPAD_read+0x11e>
				{
					DIO_togglepin( DIO_PORTD , DIO_PIN0);
 5ce:	60 e0       	ldi	r22, 0x00	; 0
 5d0:	83 e0       	ldi	r24, 0x03	; 3
 5d2:	0e 94 63 05 	call	0xac6	; 0xac6 <DIO_togglepin>
					return KEYPAD_readSuccess;
 5d6:	80 e0       	ldi	r24, 0x00	; 0
 5d8:	26 c0       	rjmp	.+76     	; 0x626 <KEYPAD_read+0x16a>
				}
				else
				{
					
					DIO_togglepin( ROW_PORT_DATA , u8_l_Rows[u8_a_rowiterator] );
 5da:	e1 e0       	ldi	r30, 0x01	; 1
 5dc:	f0 e0       	ldi	r31, 0x00	; 0
 5de:	ec 0f       	add	r30, r28
 5e0:	fd 1f       	adc	r31, r29
 5e2:	e0 0f       	add	r30, r16
 5e4:	f1 1d       	adc	r31, r1
 5e6:	60 81       	ld	r22, Z
 5e8:	82 e0       	ldi	r24, 0x02	; 2
 5ea:	0e 94 63 05 	call	0xac6	; 0xac6 <DIO_togglepin>
					return KEYPAD_readSuccess;
 5ee:	80 e0       	ldi	r24, 0x00	; 0
 5f0:	1a c0       	rjmp	.+52     	; 0x626 <KEYPAD_read+0x16a>
		else
		{
			DIO_setpinvalue(ROW_PORT_DATA , u8_l_Rows[u8_a_rowiterator] , u8_l_pinValue);
		}

        for (u8_a_coulumniterator = 0; u8_a_coulumniterator < COLUMNS_SIZE; u8_a_coulumniterator++)
 5f2:	1f 5f       	subi	r17, 0xFF	; 255
 5f4:	13 30       	cpi	r17, 0x03	; 3
 5f6:	08 f4       	brcc	.+2      	; 0x5fa <KEYPAD_read+0x13e>
 5f8:	97 cf       	rjmp	.-210    	; 0x528 <KEYPAD_read+0x6c>
					DIO_togglepin( ROW_PORT_DATA , u8_l_Rows[u8_a_rowiterator] );
					return KEYPAD_readSuccess;
				}
            }
        }
		if (u8_a_rowiterator == 3)
 5fa:	03 30       	cpi	r16, 0x03	; 3
 5fc:	29 f4       	brne	.+10     	; 0x608 <KEYPAD_read+0x14c>
		{
			DIO_togglepin( DIO_PORTD , DIO_PIN0);
 5fe:	60 e0       	ldi	r22, 0x00	; 0
 600:	83 e0       	ldi	r24, 0x03	; 3
 602:	0e 94 63 05 	call	0xac6	; 0xac6 <DIO_togglepin>
 606:	0a c0       	rjmp	.+20     	; 0x61c <KEYPAD_read+0x160>
		}
		else
		{
			DIO_togglepin( ROW_PORT_DATA , u8_l_Rows[u8_a_rowiterator] );
 608:	e1 e0       	ldi	r30, 0x01	; 1
 60a:	f0 e0       	ldi	r31, 0x00	; 0
 60c:	ec 0f       	add	r30, r28
 60e:	fd 1f       	adc	r31, r29
 610:	e0 0f       	add	r30, r16
 612:	f1 1d       	adc	r31, r1
 614:	60 81       	ld	r22, Z
 616:	82 e0       	ldi	r24, 0x02	; 2
 618:	0e 94 63 05 	call	0xac6	; 0xac6 <DIO_togglepin>
    #endif

    uint8_t u8_l_Rows[ROWS_SIZE] = {R1, R2, R3};
    uint8_t u8_l_Columns[COLUMNS_SIZE] = {C1, C2, C3};

    for (u8_a_rowiterator = 0; u8_a_rowiterator < ROWS_SIZE; u8_a_rowiterator++)
 61c:	0f 5f       	subi	r16, 0xFF	; 255
 61e:	04 30       	cpi	r16, 0x04	; 4
 620:	08 f4       	brcc	.+2      	; 0x624 <KEYPAD_read+0x168>
 622:	6d cf       	rjmp	.-294    	; 0x4fe <KEYPAD_read+0x42>
		else
		{
			DIO_togglepin( ROW_PORT_DATA , u8_l_Rows[u8_a_rowiterator] );
		}
    }
    return KEYPAD_readFail;
 624:	81 e0       	ldi	r24, 0x01	; 1
 626:	27 96       	adiw	r28, 0x07	; 7
 628:	0f b6       	in	r0, 0x3f	; 63
 62a:	f8 94       	cli
 62c:	de bf       	out	0x3e, r29	; 62
 62e:	0f be       	out	0x3f, r0	; 63
 630:	cd bf       	out	0x3d, r28	; 61
 632:	df 91       	pop	r29
 634:	cf 91       	pop	r28
 636:	1f 91       	pop	r17
 638:	0f 91       	pop	r16
 63a:	ff 90       	pop	r15
 63c:	ef 90       	pop	r14
 63e:	08 95       	ret

00000640 <LCD_sendcmd>:
/** FUNCTION TO SEND COMMAND TO LCD                       */
/** ARGUMENTS   : COMMAND                                 */
/** RETURNS     : ERROR STATUS                            */
/**********************************************************/
LCD_status LCD_sendcmd(uint8_t u8_a_cmd)
{
 640:	cf 93       	push	r28
 642:	c8 2f       	mov	r28, r24
	TMR0_init();
 644:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <TMR0_init>
		DIO_setpinvalue(LCD_8BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_LOW);  /** LATCH **/
		TMR0_delayms(5); /** LOW **/
		
		#elif LCD_MODE == BIT_MODE_4    /** IF LCD CONFIGURED AS 4 BIT MODE **/
		
		DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_RS_PIN , DIO_PIN_LOW);  /** COMMAND MODE       **/
 648:	40 e0       	ldi	r20, 0x00	; 0
 64a:	61 e0       	ldi	r22, 0x01	; 1
 64c:	80 e0       	ldi	r24, 0x00	; 0
 64e:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_RW_PIN , DIO_PIN_LOW);  /** WRITE TO LCD MODE  **/
 652:	40 e0       	ldi	r20, 0x00	; 0
 654:	62 e0       	ldi	r22, 0x02	; 2
 656:	80 e0       	ldi	r24, 0x00	; 0
 658:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_LOW);   /** PREPARE FOR LATCH  **/
 65c:	40 e0       	ldi	r20, 0x00	; 0
 65e:	63 e0       	ldi	r22, 0x03	; 3
 660:	80 e0       	ldi	r24, 0x00	; 0
 662:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		
		PORTA = ((u8_a_cmd & 0xF0) | (PORTA & 0x0F)); /** SEND THE MSB(HIGH NIBBLE) **/
 666:	8b b3       	in	r24, 0x1b	; 27
 668:	9c 2f       	mov	r25, r28
 66a:	90 7f       	andi	r25, 0xF0	; 240
 66c:	8f 70       	andi	r24, 0x0F	; 15
 66e:	89 2b       	or	r24, r25
 670:	8b bb       	out	0x1b, r24	; 27
		
		DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_HIGH); /** LATCH **/
 672:	41 e0       	ldi	r20, 0x01	; 1
 674:	63 e0       	ldi	r22, 0x03	; 3
 676:	80 e0       	ldi	r24, 0x00	; 0
 678:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		TMR0_delayms(1);
 67c:	61 e0       	ldi	r22, 0x01	; 1
 67e:	70 e0       	ldi	r23, 0x00	; 0
 680:	80 e0       	ldi	r24, 0x00	; 0
 682:	90 e0       	ldi	r25, 0x00	; 0
 684:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_LOW);  /** LATCH **/
 688:	40 e0       	ldi	r20, 0x00	; 0
 68a:	63 e0       	ldi	r22, 0x03	; 3
 68c:	80 e0       	ldi	r24, 0x00	; 0
 68e:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		
		
		PORTA = (((u8_a_cmd << 4) & 0xF0) | (PORTA & 0x0F)); /** SEND THE LSB(LOW NIBBLE) **/
 692:	20 e1       	ldi	r18, 0x10	; 16
 694:	c2 9f       	mul	r28, r18
 696:	c0 01       	movw	r24, r0
 698:	11 24       	eor	r1, r1
 69a:	9b b3       	in	r25, 0x1b	; 27
 69c:	9f 70       	andi	r25, 0x0F	; 15
 69e:	89 2b       	or	r24, r25
 6a0:	8b bb       	out	0x1b, r24	; 27
		
		DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_HIGH); /** LATCH **/
 6a2:	41 e0       	ldi	r20, 0x01	; 1
 6a4:	63 e0       	ldi	r22, 0x03	; 3
 6a6:	80 e0       	ldi	r24, 0x00	; 0
 6a8:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		TMR0_delayms(1);
 6ac:	61 e0       	ldi	r22, 0x01	; 1
 6ae:	70 e0       	ldi	r23, 0x00	; 0
 6b0:	80 e0       	ldi	r24, 0x00	; 0
 6b2:	90 e0       	ldi	r25, 0x00	; 0
 6b4:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		
		DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_LOW);    /** LATCH **/
 6b8:	40 e0       	ldi	r20, 0x00	; 0
 6ba:	63 e0       	ldi	r22, 0x03	; 3
 6bc:	80 e0       	ldi	r24, 0x00	; 0
 6be:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		
		TMR0_delayms(5); /** 5 ms BEFORE SENDING THE NEXT COMMAND **/
 6c2:	65 e0       	ldi	r22, 0x05	; 5
 6c4:	70 e0       	ldi	r23, 0x00	; 0
 6c6:	80 e0       	ldi	r24, 0x00	; 0
 6c8:	90 e0       	ldi	r25, 0x00	; 0
 6ca:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		
		#endif
}
 6ce:	cf 91       	pop	r28
 6d0:	08 95       	ret

000006d2 <LCD_init>:
/**********************************************************/
LCD_status LCD_init(void)
{
	LCD_status en_a_lcdinitstatus = VALID__LCD_INIT ; /** VARIABLE TO OLD THE RETURN STATUS OF THE FUNCTION **/
	
	TMR0_init();
 6d2:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <TMR0_init>
		LCD_sendcmd(LCD_CLEAR);       /** CLEAR THE LCD                                    **/
		
		
		#elif LCD_MODE == BIT_MODE_4    /** IF LCD CONFIGURED AS 4 BIT MODE **/
		
		DIO_setpindir(LCD_4BIT_CMD_PORT , LCD_RS_PIN , DIO_PIN_OUTPUT); /** SET RS PIN AS OUTPUT PIN **/
 6d6:	41 e0       	ldi	r20, 0x01	; 1
 6d8:	61 e0       	ldi	r22, 0x01	; 1
 6da:	80 e0       	ldi	r24, 0x00	; 0
 6dc:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
		DIO_setpindir(LCD_4BIT_CMD_PORT , LCD_RW_PIN , DIO_PIN_OUTPUT); /** SET RW PIN AS OUTPUT PIN **/
 6e0:	41 e0       	ldi	r20, 0x01	; 1
 6e2:	62 e0       	ldi	r22, 0x02	; 2
 6e4:	80 e0       	ldi	r24, 0x00	; 0
 6e6:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
		DIO_setpindir(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_OUTPUT);  /** SET E PIN AS OUTPUT PIN  **/
 6ea:	41 e0       	ldi	r20, 0x01	; 1
 6ec:	63 e0       	ldi	r22, 0x03	; 3
 6ee:	80 e0       	ldi	r24, 0x00	; 0
 6f0:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
		
		DIO_setpindir(LCD_4BIT_DATA_PORT , LCD_D4_PIN , DIO_PIN_OUTPUT); /** 4 DATA PINS AS OUTPUT **/
 6f4:	41 e0       	ldi	r20, 0x01	; 1
 6f6:	64 e0       	ldi	r22, 0x04	; 4
 6f8:	80 e0       	ldi	r24, 0x00	; 0
 6fa:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
		DIO_setpindir(LCD_4BIT_DATA_PORT , LCD_D5_PIN , DIO_PIN_OUTPUT);
 6fe:	41 e0       	ldi	r20, 0x01	; 1
 700:	65 e0       	ldi	r22, 0x05	; 5
 702:	80 e0       	ldi	r24, 0x00	; 0
 704:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
		DIO_setpindir(LCD_4BIT_DATA_PORT , LCD_D6_PIN , DIO_PIN_OUTPUT);
 708:	41 e0       	ldi	r20, 0x01	; 1
 70a:	66 e0       	ldi	r22, 0x06	; 6
 70c:	80 e0       	ldi	r24, 0x00	; 0
 70e:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
		DIO_setpindir(LCD_4BIT_DATA_PORT , LCD_D7_PIN , DIO_PIN_OUTPUT);
 712:	41 e0       	ldi	r20, 0x01	; 1
 714:	67 e0       	ldi	r22, 0x07	; 7
 716:	80 e0       	ldi	r24, 0x00	; 0
 718:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
		
		TMR0_delayms(20); /** DELAY FOR LCD TO BE INITIALIZED **/
 71c:	64 e1       	ldi	r22, 0x14	; 20
 71e:	70 e0       	ldi	r23, 0x00	; 0
 720:	80 e0       	ldi	r24, 0x00	; 0
 722:	90 e0       	ldi	r25, 0x00	; 0
 724:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
		
		/** SEND SOME COMMANDS TO THE LCD FOR INITIAL SET   **/
		
		LCD_sendcmd(LCD_4BIT_MODE_CMD1); /** SEND THREE COMMANDS FOR LCD TO SET 4 BIT OPERATION MODE ( 2 LINES , 5*8 MATRIX ) **/
 728:	83 e3       	ldi	r24, 0x33	; 51
 72a:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		LCD_sendcmd(LCD_4BIT_MODE_CMD2);
 72e:	82 e3       	ldi	r24, 0x32	; 50
 730:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		LCD_sendcmd(LCD_4BIT_MODE_CMD3);
 734:	88 e2       	ldi	r24, 0x28	; 40
 736:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		
		LCD_sendcmd(LCD_CURSOR_OFF);     /** NO NEED FOR CURSOR SO IT IS OFF                  **/
 73a:	8c e0       	ldi	r24, 0x0C	; 12
 73c:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		LCD_sendcmd(LCD_CURSOR_INC);     /** DIRECTION OF WRITING FROM LEFT TO RIGHT          **/
 740:	86 e0       	ldi	r24, 0x06	; 6
 742:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		LCD_sendcmd(LCD_RETURN_HOME);    /** CURSOR STARTS FROM ITS HOME POSITION             **/
 746:	82 e0       	ldi	r24, 0x02	; 2
 748:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		LCD_sendcmd(LCD_CLEAR);          /** CLEAR THE LCD                                    **/
 74c:	81 e0       	ldi	r24, 0x01	; 1
 74e:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
		
		#endif 
		
}
 752:	08 95       	ret

00000754 <LCD_writechar>:
/** FUNCTION TO DISPLAY CHARACTER ON LCD                  */
/** ARGUMENTS   : CHARACTER                               */
/** RETURNS     : ERROR STATUS                            */
/**********************************************************/
LCD_status LCD_writechar(uint8_t u8_a_chr)
{
 754:	cf 93       	push	r28
 756:	c8 2f       	mov	r28, r24
	
	TMR0_delayms(5); /** 5 ms BEFORE SENDING THE NEXT CHARACTER **/
	
	#elif LCD_MODE == BIT_MODE_4    /** IF LCD CONFIGURED AS 4 BIT MODE **/
	
	DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_RS_PIN , DIO_PIN_HIGH);  /** DATA MODE         **/
 758:	41 e0       	ldi	r20, 0x01	; 1
 75a:	61 e0       	ldi	r22, 0x01	; 1
 75c:	80 e0       	ldi	r24, 0x00	; 0
 75e:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_RW_PIN , DIO_PIN_LOW);   /** WRITE TO LCD MODE **/
 762:	40 e0       	ldi	r20, 0x00	; 0
 764:	62 e0       	ldi	r22, 0x02	; 2
 766:	80 e0       	ldi	r24, 0x00	; 0
 768:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_LOW);    /** DATA MODE         **/
 76c:	40 e0       	ldi	r20, 0x00	; 0
 76e:	63 e0       	ldi	r22, 0x03	; 3
 770:	80 e0       	ldi	r24, 0x00	; 0
 772:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	
	
	PORTA = ((u8_a_chr & 0xF0) | (PORTA & 0x0F)); /** SEND THE MSB (HIGH NIBBLE) **/
 776:	8b b3       	in	r24, 0x1b	; 27
 778:	9c 2f       	mov	r25, r28
 77a:	90 7f       	andi	r25, 0xF0	; 240
 77c:	8f 70       	andi	r24, 0x0F	; 15
 77e:	89 2b       	or	r24, r25
 780:	8b bb       	out	0x1b, r24	; 27
	
	DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_HIGH); /** LATCH **/
 782:	41 e0       	ldi	r20, 0x01	; 1
 784:	63 e0       	ldi	r22, 0x03	; 3
 786:	80 e0       	ldi	r24, 0x00	; 0
 788:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	TMR0_delayms(1);
 78c:	61 e0       	ldi	r22, 0x01	; 1
 78e:	70 e0       	ldi	r23, 0x00	; 0
 790:	80 e0       	ldi	r24, 0x00	; 0
 792:	90 e0       	ldi	r25, 0x00	; 0
 794:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_LOW); /** LATCH **/
 798:	40 e0       	ldi	r20, 0x00	; 0
 79a:	63 e0       	ldi	r22, 0x03	; 3
 79c:	80 e0       	ldi	r24, 0x00	; 0
 79e:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
		
	PORTA = (((u8_a_chr << 4) & 0xF0) | (PORTA & 0x0F)); /** SEND THE LSB (LOW NIBBLE) **/
 7a2:	20 e1       	ldi	r18, 0x10	; 16
 7a4:	c2 9f       	mul	r28, r18
 7a6:	c0 01       	movw	r24, r0
 7a8:	11 24       	eor	r1, r1
 7aa:	9b b3       	in	r25, 0x1b	; 27
 7ac:	9f 70       	andi	r25, 0x0F	; 15
 7ae:	89 2b       	or	r24, r25
 7b0:	8b bb       	out	0x1b, r24	; 27
	
	DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_HIGH); /** LATCH **/
 7b2:	41 e0       	ldi	r20, 0x01	; 1
 7b4:	63 e0       	ldi	r22, 0x03	; 3
 7b6:	80 e0       	ldi	r24, 0x00	; 0
 7b8:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	TMR0_delayms(1);
 7bc:	61 e0       	ldi	r22, 0x01	; 1
 7be:	70 e0       	ldi	r23, 0x00	; 0
 7c0:	80 e0       	ldi	r24, 0x00	; 0
 7c2:	90 e0       	ldi	r25, 0x00	; 0
 7c4:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	DIO_setpinvalue(LCD_4BIT_CMD_PORT , LCD_E_PIN , DIO_PIN_LOW);  /** LATCH **/
 7c8:	40 e0       	ldi	r20, 0x00	; 0
 7ca:	63 e0       	ldi	r22, 0x03	; 3
 7cc:	80 e0       	ldi	r24, 0x00	; 0
 7ce:	0e 94 a6 04 	call	0x94c	; 0x94c <DIO_setpinvalue>
	
	TMR0_delayms(5); /** 5 ms BEFORE SENDING THE NEXT CHARACTER **/
 7d2:	65 e0       	ldi	r22, 0x05	; 5
 7d4:	70 e0       	ldi	r23, 0x00	; 0
 7d6:	80 e0       	ldi	r24, 0x00	; 0
 7d8:	90 e0       	ldi	r25, 0x00	; 0
 7da:	0e 94 00 06 	call	0xc00	; 0xc00 <TMR0_delayms>
	
	#endif
}
 7de:	cf 91       	pop	r28
 7e0:	08 95       	ret

000007e2 <LCD_writestr>:
/** FUNCTION TO DISPLAY STRING ON LCD                     */
/** ARGUMENTS   : STRING                                  */
/** RETURNS     : ERROR STATUS                            */
/**********************************************************/
LCD_status LCD_writestr(uint8_t* u8_s_str)
{
 7e2:	0f 93       	push	r16
 7e4:	1f 93       	push	r17
 7e6:	cf 93       	push	r28
 7e8:	8c 01       	movw	r16, r24
	uint8_t u8_a_letter = 0;   /** VARIABLE SIMULATES LETTER **/
 7ea:	c0 e0       	ldi	r28, 0x00	; 0
	
	while (u8_s_str[u8_a_letter] != '\0') /** WHILE LETTER ISN'T NULL **/
 7ec:	03 c0       	rjmp	.+6      	; 0x7f4 <LCD_writestr+0x12>
	{
		LCD_writechar(u8_s_str[u8_a_letter]); /** SEND LETTER TO LCD **/
 7ee:	0e 94 aa 03 	call	0x754	; 0x754 <LCD_writechar>
		
		u8_a_letter++; /** JUMP TO THE NEXT LETTER **/
 7f2:	cf 5f       	subi	r28, 0xFF	; 255
/**********************************************************/
LCD_status LCD_writestr(uint8_t* u8_s_str)
{
	uint8_t u8_a_letter = 0;   /** VARIABLE SIMULATES LETTER **/
	
	while (u8_s_str[u8_a_letter] != '\0') /** WHILE LETTER ISN'T NULL **/
 7f4:	f8 01       	movw	r30, r16
 7f6:	ec 0f       	add	r30, r28
 7f8:	f1 1d       	adc	r31, r1
 7fa:	80 81       	ld	r24, Z
 7fc:	81 11       	cpse	r24, r1
 7fe:	f7 cf       	rjmp	.-18     	; 0x7ee <LCD_writestr+0xc>
	{
		LCD_writechar(u8_s_str[u8_a_letter]); /** SEND LETTER TO LCD **/
		
		u8_a_letter++; /** JUMP TO THE NEXT LETTER **/
	}
}
 800:	cf 91       	pop	r28
 802:	1f 91       	pop	r17
 804:	0f 91       	pop	r16
 806:	08 95       	ret

00000808 <LCD_goto>:
/** FUNCTION TO JUMP TO SPECIFIC POSITION ON LCD          */
/** ARGUMENTS   : ROW , COLUMN (POSITION)                 */
/** RETURNS     : ERROR STATUS                            */
/**********************************************************/
LCD_status  LCD_goto(uint8_t u8_a_row , uint8_t u8_a_column)
{
 808:	cf 93       	push	r28
 80a:	df 93       	push	r29
 80c:	00 d0       	rcall	.+0      	; 0x80e <LCD_goto+0x6>
 80e:	cd b7       	in	r28, 0x3d	; 61
 810:	de b7       	in	r29, 0x3e	; 62
	uint8_t positions[2] = {0x80 , 0xC0}; /** POSITIONS OF 1st & 2nd ROWS **/
 812:	90 e8       	ldi	r25, 0x80	; 128
 814:	99 83       	std	Y+1, r25	; 0x01
 816:	90 ec       	ldi	r25, 0xC0	; 192
 818:	9a 83       	std	Y+2, r25	; 0x02
	
	LCD_sendcmd(positions[u8_a_row] + u8_a_column); /** GO TO SPECIFIC MATRIX **/
 81a:	e1 e0       	ldi	r30, 0x01	; 1
 81c:	f0 e0       	ldi	r31, 0x00	; 0
 81e:	ec 0f       	add	r30, r28
 820:	fd 1f       	adc	r31, r29
 822:	e8 0f       	add	r30, r24
 824:	f1 1d       	adc	r31, r1
 826:	80 81       	ld	r24, Z
 828:	86 0f       	add	r24, r22
 82a:	0e 94 20 03 	call	0x640	; 0x640 <LCD_sendcmd>
}
 82e:	0f 90       	pop	r0
 830:	0f 90       	pop	r0
 832:	df 91       	pop	r29
 834:	cf 91       	pop	r28
 836:	08 95       	ret

00000838 <main>:

#include "APP/APP.h"

int main(void)
{
	APP_init(); /** INITIALIZATION **/
 838:	0e 94 49 00 	call	0x92	; 0x92 <APP_init>
	
	APP_readuserpin(); /** READ USER PIN **/
 83c:	0e 94 98 00 	call	0x130	; 0x130 <APP_readuserpin>
	
	APP_startcardcomm();  /** START **/ 
 840:	0e 94 e7 00 	call	0x1ce	; 0x1ce <APP_startcardcomm>
	
	//APP_pinvalidate(); /** VALIDATE USER INPUT **/
	
	APP_getamount(); /** GET NEEDED MONEY **/
 844:	0e 94 4c 01 	call	0x298	; 0x298 <APP_getamount>
// 	while (1)
// 	{
// 		
// 	
// 	}
}
 848:	80 e0       	ldi	r24, 0x00	; 0
 84a:	90 e0       	ldi	r25, 0x00	; 0
 84c:	08 95       	ret

0000084e <DIO_setpindir>:
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
	
	switch(u8_a_pindir) /** SWITCH CASE ON THE DIRECTION VALUE **/
 84e:	44 23       	and	r20, r20
 850:	19 f0       	breq	.+6      	; 0x858 <DIO_setpindir+0xa>
 852:	41 30       	cpi	r20, 0x01	; 1
 854:	e9 f1       	breq	.+122    	; 0x8d0 <__stack+0x71>
 856:	74 c0       	rjmp	.+232    	; 0x940 <__stack+0xe1>
	{
		case DIO_PIN_INPUT:  /* INPUT CASE  */
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
 858:	81 30       	cpi	r24, 0x01	; 1
 85a:	99 f0       	breq	.+38     	; 0x882 <__stack+0x23>
 85c:	28 f0       	brcs	.+10     	; 0x868 <__stack+0x9>
 85e:	82 30       	cpi	r24, 0x02	; 2
 860:	e9 f0       	breq	.+58     	; 0x89c <__stack+0x3d>
 862:	83 30       	cpi	r24, 0x03	; 3
 864:	41 f1       	breq	.+80     	; 0x8b6 <__stack+0x57>
 866:	6e c0       	rjmp	.+220    	; 0x944 <__stack+0xe5>
		{
			case DIO_PORTA:
			clear_bit(DDRA , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTA AS INPUT PIN **/
 868:	2a b3       	in	r18, 0x1a	; 26
 86a:	81 e0       	ldi	r24, 0x01	; 1
 86c:	90 e0       	ldi	r25, 0x00	; 0
 86e:	02 c0       	rjmp	.+4      	; 0x874 <__stack+0x15>
 870:	88 0f       	add	r24, r24
 872:	99 1f       	adc	r25, r25
 874:	6a 95       	dec	r22
 876:	e2 f7       	brpl	.-8      	; 0x870 <__stack+0x11>
 878:	80 95       	com	r24
 87a:	82 23       	and	r24, r18
 87c:	8a bb       	out	0x1a, r24	; 26
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 87e:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
		{
			case DIO_PORTA:
			clear_bit(DDRA , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTA AS INPUT PIN **/
			break;
 880:	08 95       	ret
			
			case DIO_PORTB:
			clear_bit(DDRB , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTB AS INPUT PIN **/
 882:	27 b3       	in	r18, 0x17	; 23
 884:	81 e0       	ldi	r24, 0x01	; 1
 886:	90 e0       	ldi	r25, 0x00	; 0
 888:	02 c0       	rjmp	.+4      	; 0x88e <__stack+0x2f>
 88a:	88 0f       	add	r24, r24
 88c:	99 1f       	adc	r25, r25
 88e:	6a 95       	dec	r22
 890:	e2 f7       	brpl	.-8      	; 0x88a <__stack+0x2b>
 892:	80 95       	com	r24
 894:	82 23       	and	r24, r18
 896:	87 bb       	out	0x17, r24	; 23
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 898:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(DDRA , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTA AS INPUT PIN **/
			break;
			
			case DIO_PORTB:
			clear_bit(DDRB , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTB AS INPUT PIN **/
			break;
 89a:	08 95       	ret
			
			case DIO_PORTC:
			clear_bit(DDRC , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTC AS INPUT PIN **/
 89c:	24 b3       	in	r18, 0x14	; 20
 89e:	81 e0       	ldi	r24, 0x01	; 1
 8a0:	90 e0       	ldi	r25, 0x00	; 0
 8a2:	02 c0       	rjmp	.+4      	; 0x8a8 <__stack+0x49>
 8a4:	88 0f       	add	r24, r24
 8a6:	99 1f       	adc	r25, r25
 8a8:	6a 95       	dec	r22
 8aa:	e2 f7       	brpl	.-8      	; 0x8a4 <__stack+0x45>
 8ac:	80 95       	com	r24
 8ae:	82 23       	and	r24, r18
 8b0:	84 bb       	out	0x14, r24	; 20
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 8b2:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(DDRB , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTB AS INPUT PIN **/
			break;
			
			case DIO_PORTC:
			clear_bit(DDRC , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTC AS INPUT PIN **/
			break;
 8b4:	08 95       	ret
			
			case DIO_PORTD:
			clear_bit(DDRD , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
 8b6:	21 b3       	in	r18, 0x11	; 17
 8b8:	81 e0       	ldi	r24, 0x01	; 1
 8ba:	90 e0       	ldi	r25, 0x00	; 0
 8bc:	02 c0       	rjmp	.+4      	; 0x8c2 <__stack+0x63>
 8be:	88 0f       	add	r24, r24
 8c0:	99 1f       	adc	r25, r25
 8c2:	6a 95       	dec	r22
 8c4:	e2 f7       	brpl	.-8      	; 0x8be <__stack+0x5f>
 8c6:	80 95       	com	r24
 8c8:	82 23       	and	r24, r18
 8ca:	81 bb       	out	0x11, r24	; 17
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 8cc:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(DDRC , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTC AS INPUT PIN **/
			break;
			
			case DIO_PORTD:
			clear_bit(DDRD , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
			break;
 8ce:	08 95       	ret
		} 
		break;
		
		case DIO_PIN_OUTPUT:  /* OUTPUT CASE  */
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
 8d0:	81 30       	cpi	r24, 0x01	; 1
 8d2:	91 f0       	breq	.+36     	; 0x8f8 <__stack+0x99>
 8d4:	28 f0       	brcs	.+10     	; 0x8e0 <__stack+0x81>
 8d6:	82 30       	cpi	r24, 0x02	; 2
 8d8:	d9 f0       	breq	.+54     	; 0x910 <__stack+0xb1>
 8da:	83 30       	cpi	r24, 0x03	; 3
 8dc:	29 f1       	breq	.+74     	; 0x928 <__stack+0xc9>
 8de:	34 c0       	rjmp	.+104    	; 0x948 <__stack+0xe9>
		{
			case DIO_PORTA:
			set_bit(DDRA , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 8e0:	2a b3       	in	r18, 0x1a	; 26
 8e2:	81 e0       	ldi	r24, 0x01	; 1
 8e4:	90 e0       	ldi	r25, 0x00	; 0
 8e6:	02 c0       	rjmp	.+4      	; 0x8ec <__stack+0x8d>
 8e8:	88 0f       	add	r24, r24
 8ea:	99 1f       	adc	r25, r25
 8ec:	6a 95       	dec	r22
 8ee:	e2 f7       	brpl	.-8      	; 0x8e8 <__stack+0x89>
 8f0:	82 2b       	or	r24, r18
 8f2:	8a bb       	out	0x1a, r24	; 26
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 8f4:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid) /** SWITCH CASE ON THE PORT ID */
		{
			case DIO_PORTA:
			set_bit(DDRA , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 8f6:	08 95       	ret
			
			case DIO_PORTB:
			set_bit(DDRB , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 8f8:	27 b3       	in	r18, 0x17	; 23
 8fa:	81 e0       	ldi	r24, 0x01	; 1
 8fc:	90 e0       	ldi	r25, 0x00	; 0
 8fe:	02 c0       	rjmp	.+4      	; 0x904 <__stack+0xa5>
 900:	88 0f       	add	r24, r24
 902:	99 1f       	adc	r25, r25
 904:	6a 95       	dec	r22
 906:	e2 f7       	brpl	.-8      	; 0x900 <__stack+0xa1>
 908:	82 2b       	or	r24, r18
 90a:	87 bb       	out	0x17, r24	; 23
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 90c:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(DDRA , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			case DIO_PORTB:
			set_bit(DDRB , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 90e:	08 95       	ret
			
			case DIO_PORTC:
			set_bit(DDRC , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 910:	24 b3       	in	r18, 0x14	; 20
 912:	81 e0       	ldi	r24, 0x01	; 1
 914:	90 e0       	ldi	r25, 0x00	; 0
 916:	02 c0       	rjmp	.+4      	; 0x91c <__stack+0xbd>
 918:	88 0f       	add	r24, r24
 91a:	99 1f       	adc	r25, r25
 91c:	6a 95       	dec	r22
 91e:	e2 f7       	brpl	.-8      	; 0x918 <__stack+0xb9>
 920:	82 2b       	or	r24, r18
 922:	84 bb       	out	0x14, r24	; 20
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 924:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(DDRB , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			case DIO_PORTC:
			set_bit(DDRC , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 926:	08 95       	ret
			
			case DIO_PORTD:
			set_bit(DDRD , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 928:	21 b3       	in	r18, 0x11	; 17
 92a:	81 e0       	ldi	r24, 0x01	; 1
 92c:	90 e0       	ldi	r25, 0x00	; 0
 92e:	02 c0       	rjmp	.+4      	; 0x934 <__stack+0xd5>
 930:	88 0f       	add	r24, r24
 932:	99 1f       	adc	r25, r25
 934:	6a 95       	dec	r22
 936:	e2 f7       	brpl	.-8      	; 0x930 <__stack+0xd1>
 938:	82 2b       	or	r24, r18
 93a:	81 bb       	out	0x11, r24	; 17
/* INPUT   : PORT , PINID , DIRECTION                             */
/* RETURNS : PinDirection_t                                       */
/******************************************************************/
PinDirection_t DIO_setpindir(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pindir)
{
	PinDirection_t en_a_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
 93c:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(DDRC , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			case DIO_PORTD:
			set_bit(DDRD , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
 93e:	08 95       	ret
		} 
		break;
		 
		 
		default:  /** DIRECTION ISN'T INPUT OR OUTPUT */
		en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 940:	81 e0       	ldi	r24, 0x01	; 1
 942:	08 95       	ret
			case DIO_PORTD:
			clear_bit(DDRD , u8_a_pinid);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
			break;
			
			default: /** DO NOTHING **/
			en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 944:	81 e0       	ldi	r24, 0x01	; 1
 946:	08 95       	ret
			case DIO_PORTD:
			set_bit(DDRD , u8_a_pinid);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			break;
			
			default:  /** DO NOTHING **/
			en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 948:	81 e0       	ldi	r24, 0x01	; 1
		en_a_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
		break ; 
	} 
	
	return en_a_dirstate ; /** RETURN THE STATE OF FUNCTION **/
}
 94a:	08 95       	ret

0000094c <DIO_setpinvalue>:
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
	
	switch(u8_a_pinval)
 94c:	44 23       	and	r20, r20
 94e:	19 f0       	breq	.+6      	; 0x956 <DIO_setpinvalue+0xa>
 950:	41 30       	cpi	r20, 0x01	; 1
 952:	e9 f1       	breq	.+122    	; 0x9ce <DIO_setpinvalue+0x82>
 954:	74 c0       	rjmp	.+232    	; 0xa3e <DIO_setpinvalue+0xf2>
	{
		case DIO_PIN_LOW:  /** IN CASE PIN VALUE IS LOW */
		
		switch(u8_a_portid)  /** SWITCH CASE ON THE PORT ID */ 
 956:	81 30       	cpi	r24, 0x01	; 1
 958:	99 f0       	breq	.+38     	; 0x980 <DIO_setpinvalue+0x34>
 95a:	28 f0       	brcs	.+10     	; 0x966 <DIO_setpinvalue+0x1a>
 95c:	82 30       	cpi	r24, 0x02	; 2
 95e:	e9 f0       	breq	.+58     	; 0x99a <DIO_setpinvalue+0x4e>
 960:	83 30       	cpi	r24, 0x03	; 3
 962:	41 f1       	breq	.+80     	; 0x9b4 <DIO_setpinvalue+0x68>
 964:	6e c0       	rjmp	.+220    	; 0xa42 <DIO_setpinvalue+0xf6>
		{
			case DIO_PORTA:
			clear_bit(PORTA , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 966:	2b b3       	in	r18, 0x1b	; 27
 968:	81 e0       	ldi	r24, 0x01	; 1
 96a:	90 e0       	ldi	r25, 0x00	; 0
 96c:	02 c0       	rjmp	.+4      	; 0x972 <DIO_setpinvalue+0x26>
 96e:	88 0f       	add	r24, r24
 970:	99 1f       	adc	r25, r25
 972:	6a 95       	dec	r22
 974:	e2 f7       	brpl	.-8      	; 0x96e <DIO_setpinvalue+0x22>
 976:	80 95       	com	r24
 978:	82 23       	and	r24, r18
 97a:	8b bb       	out	0x1b, r24	; 27
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 97c:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid)  /** SWITCH CASE ON THE PORT ID */ 
		{
			case DIO_PORTA:
			clear_bit(PORTA , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 97e:	08 95       	ret
			
			case DIO_PORTB:
			clear_bit(PORTB , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 980:	28 b3       	in	r18, 0x18	; 24
 982:	81 e0       	ldi	r24, 0x01	; 1
 984:	90 e0       	ldi	r25, 0x00	; 0
 986:	02 c0       	rjmp	.+4      	; 0x98c <DIO_setpinvalue+0x40>
 988:	88 0f       	add	r24, r24
 98a:	99 1f       	adc	r25, r25
 98c:	6a 95       	dec	r22
 98e:	e2 f7       	brpl	.-8      	; 0x988 <DIO_setpinvalue+0x3c>
 990:	80 95       	com	r24
 992:	82 23       	and	r24, r18
 994:	88 bb       	out	0x18, r24	; 24
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 996:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(PORTA , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			case DIO_PORTB:
			clear_bit(PORTB , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 998:	08 95       	ret
			
			case DIO_PORTC:
			clear_bit(PORTC , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 99a:	25 b3       	in	r18, 0x15	; 21
 99c:	81 e0       	ldi	r24, 0x01	; 1
 99e:	90 e0       	ldi	r25, 0x00	; 0
 9a0:	02 c0       	rjmp	.+4      	; 0x9a6 <DIO_setpinvalue+0x5a>
 9a2:	88 0f       	add	r24, r24
 9a4:	99 1f       	adc	r25, r25
 9a6:	6a 95       	dec	r22
 9a8:	e2 f7       	brpl	.-8      	; 0x9a2 <DIO_setpinvalue+0x56>
 9aa:	80 95       	com	r24
 9ac:	82 23       	and	r24, r18
 9ae:	85 bb       	out	0x15, r24	; 21
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 9b0:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(PORTB , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			case DIO_PORTC:
			clear_bit(PORTC , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 9b2:	08 95       	ret
			
			case DIO_PORTD:
			clear_bit(PORTD , u8_a_pinid);       /** SET THIS PIN AS LOW **/
 9b4:	22 b3       	in	r18, 0x12	; 18
 9b6:	81 e0       	ldi	r24, 0x01	; 1
 9b8:	90 e0       	ldi	r25, 0x00	; 0
 9ba:	02 c0       	rjmp	.+4      	; 0x9c0 <DIO_setpinvalue+0x74>
 9bc:	88 0f       	add	r24, r24
 9be:	99 1f       	adc	r25, r25
 9c0:	6a 95       	dec	r22
 9c2:	e2 f7       	brpl	.-8      	; 0x9bc <DIO_setpinvalue+0x70>
 9c4:	80 95       	com	r24
 9c6:	82 23       	and	r24, r18
 9c8:	82 bb       	out	0x12, r24	; 18
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 9ca:	80 e0       	ldi	r24, 0x00	; 0
			clear_bit(PORTC , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			case DIO_PORTD:
			clear_bit(PORTD , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
 9cc:	08 95       	ret
		} 
		break;
		
		case DIO_PIN_HIGH:
		
		switch(u8_a_portid)
 9ce:	81 30       	cpi	r24, 0x01	; 1
 9d0:	91 f0       	breq	.+36     	; 0x9f6 <DIO_setpinvalue+0xaa>
 9d2:	28 f0       	brcs	.+10     	; 0x9de <DIO_setpinvalue+0x92>
 9d4:	82 30       	cpi	r24, 0x02	; 2
 9d6:	d9 f0       	breq	.+54     	; 0xa0e <DIO_setpinvalue+0xc2>
 9d8:	83 30       	cpi	r24, 0x03	; 3
 9da:	29 f1       	breq	.+74     	; 0xa26 <DIO_setpinvalue+0xda>
 9dc:	34 c0       	rjmp	.+104    	; 0xa46 <DIO_setpinvalue+0xfa>
		{
			case DIO_PORTA:
			set_bit(PORTA , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 9de:	2b b3       	in	r18, 0x1b	; 27
 9e0:	81 e0       	ldi	r24, 0x01	; 1
 9e2:	90 e0       	ldi	r25, 0x00	; 0
 9e4:	02 c0       	rjmp	.+4      	; 0x9ea <DIO_setpinvalue+0x9e>
 9e6:	88 0f       	add	r24, r24
 9e8:	99 1f       	adc	r25, r25
 9ea:	6a 95       	dec	r22
 9ec:	e2 f7       	brpl	.-8      	; 0x9e6 <DIO_setpinvalue+0x9a>
 9ee:	82 2b       	or	r24, r18
 9f0:	8b bb       	out	0x1b, r24	; 27
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 9f2:	80 e0       	ldi	r24, 0x00	; 0
		
		switch(u8_a_portid)
		{
			case DIO_PORTA:
			set_bit(PORTA , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 9f4:	08 95       	ret
			
			case DIO_PORTB:
			set_bit(PORTB , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 9f6:	28 b3       	in	r18, 0x18	; 24
 9f8:	81 e0       	ldi	r24, 0x01	; 1
 9fa:	90 e0       	ldi	r25, 0x00	; 0
 9fc:	02 c0       	rjmp	.+4      	; 0xa02 <DIO_setpinvalue+0xb6>
 9fe:	88 0f       	add	r24, r24
 a00:	99 1f       	adc	r25, r25
 a02:	6a 95       	dec	r22
 a04:	e2 f7       	brpl	.-8      	; 0x9fe <DIO_setpinvalue+0xb2>
 a06:	82 2b       	or	r24, r18
 a08:	88 bb       	out	0x18, r24	; 24
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 a0a:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(PORTA , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			case DIO_PORTB:
			set_bit(PORTB , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 a0c:	08 95       	ret
			
			case DIO_PORTC:
			set_bit(PORTC , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 a0e:	25 b3       	in	r18, 0x15	; 21
 a10:	81 e0       	ldi	r24, 0x01	; 1
 a12:	90 e0       	ldi	r25, 0x00	; 0
 a14:	02 c0       	rjmp	.+4      	; 0xa1a <DIO_setpinvalue+0xce>
 a16:	88 0f       	add	r24, r24
 a18:	99 1f       	adc	r25, r25
 a1a:	6a 95       	dec	r22
 a1c:	e2 f7       	brpl	.-8      	; 0xa16 <DIO_setpinvalue+0xca>
 a1e:	82 2b       	or	r24, r18
 a20:	85 bb       	out	0x15, r24	; 21
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 a22:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(PORTB , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			case DIO_PORTC:
			set_bit(PORTC , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 a24:	08 95       	ret
			
			case DIO_PORTD:
			set_bit(PORTD , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
 a26:	22 b3       	in	r18, 0x12	; 18
 a28:	81 e0       	ldi	r24, 0x01	; 1
 a2a:	90 e0       	ldi	r25, 0x00	; 0
 a2c:	02 c0       	rjmp	.+4      	; 0xa32 <DIO_setpinvalue+0xe6>
 a2e:	88 0f       	add	r24, r24
 a30:	99 1f       	adc	r25, r25
 a32:	6a 95       	dec	r22
 a34:	e2 f7       	brpl	.-8      	; 0xa2e <DIO_setpinvalue+0xe2>
 a36:	82 2b       	or	r24, r18
 a38:	82 bb       	out	0x12, r24	; 18
/* RETURNS : PinValue_t                                           */
/******************************************************************/
PinValue_t DIO_setpinvalue(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t u8_a_pinval)
{
	
	PinValue_t en_a_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
 a3a:	80 e0       	ldi	r24, 0x00	; 0
			set_bit(PORTC , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			case DIO_PORTD:
			set_bit(PORTD , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
 a3c:	08 95       	ret
			break;
		} 
		break;
		
		default :
		en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 a3e:	81 e0       	ldi	r24, 0x01	; 1
 a40:	08 95       	ret
			case DIO_PORTD:
			clear_bit(PORTD , u8_a_pinid);       /** SET THIS PIN AS LOW **/
			break;
			
			default:
			en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 a42:	81 e0       	ldi	r24, 0x01	; 1
 a44:	08 95       	ret
			case DIO_PORTD:
			set_bit(PORTD , u8_a_pinid);         /** SET THIS PIN AS HIGH  **/
			break;
			
			default:
			en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 a46:	81 e0       	ldi	r24, 0x01	; 1
		en_a_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
		break ;
	} 
	
	return en_a_valstate ; /** RETURN THE FINAL STATE OF THE FUNCTION */
}
 a48:	08 95       	ret

00000a4a <DIO_readpin>:
/******************************************************************/
PinRead_t DIO_readpin(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t* u8_a_val)
{
	PinRead_t en_a_Pinstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
	
	switch(u8_a_portid)  /** SWITCH CASE ON PORT ID **/
 a4a:	81 30       	cpi	r24, 0x01	; 1
 a4c:	99 f0       	breq	.+38     	; 0xa74 <DIO_readpin+0x2a>
 a4e:	28 f0       	brcs	.+10     	; 0xa5a <DIO_readpin+0x10>
 a50:	82 30       	cpi	r24, 0x02	; 2
 a52:	e9 f0       	breq	.+58     	; 0xa8e <DIO_readpin+0x44>
 a54:	83 30       	cpi	r24, 0x03	; 3
 a56:	41 f1       	breq	.+80     	; 0xaa8 <DIO_readpin+0x5e>
 a58:	34 c0       	rjmp	.+104    	; 0xac2 <DIO_readpin+0x78>
	{
		case DIO_PORTA:               /** PORTA  **/
		*u8_a_val = get_bit(PINA , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
 a5a:	89 b3       	in	r24, 0x19	; 25
 a5c:	90 e0       	ldi	r25, 0x00	; 0
 a5e:	02 c0       	rjmp	.+4      	; 0xa64 <DIO_readpin+0x1a>
 a60:	95 95       	asr	r25
 a62:	87 95       	ror	r24
 a64:	6a 95       	dec	r22
 a66:	e2 f7       	brpl	.-8      	; 0xa60 <DIO_readpin+0x16>
 a68:	81 70       	andi	r24, 0x01	; 1
 a6a:	89 bb       	out	0x19, r24	; 25
 a6c:	fa 01       	movw	r30, r20
 a6e:	80 83       	st	Z, r24
/* INPUT   : u8_a_portid , PINID , POINTER TO SET THE VALUE IN IT      */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_readpin(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t* u8_a_val)
{
	PinRead_t en_a_Pinstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 a70:	80 e0       	ldi	r24, 0x00	; 0
	
	switch(u8_a_portid)  /** SWITCH CASE ON PORT ID **/
	{
		case DIO_PORTA:               /** PORTA  **/
		*u8_a_val = get_bit(PINA , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
		break;
 a72:	08 95       	ret
		
		case DIO_PORTB:               /** PORTB  **/
		*u8_a_val = get_bit(PINB , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
 a74:	86 b3       	in	r24, 0x16	; 22
 a76:	90 e0       	ldi	r25, 0x00	; 0
 a78:	02 c0       	rjmp	.+4      	; 0xa7e <DIO_readpin+0x34>
 a7a:	95 95       	asr	r25
 a7c:	87 95       	ror	r24
 a7e:	6a 95       	dec	r22
 a80:	e2 f7       	brpl	.-8      	; 0xa7a <DIO_readpin+0x30>
 a82:	81 70       	andi	r24, 0x01	; 1
 a84:	86 bb       	out	0x16, r24	; 22
 a86:	fa 01       	movw	r30, r20
 a88:	80 83       	st	Z, r24
/* INPUT   : u8_a_portid , PINID , POINTER TO SET THE VALUE IN IT      */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_readpin(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t* u8_a_val)
{
	PinRead_t en_a_Pinstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 a8a:	80 e0       	ldi	r24, 0x00	; 0
		*u8_a_val = get_bit(PINA , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
		break;
		
		case DIO_PORTB:               /** PORTB  **/
		*u8_a_val = get_bit(PINB , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
		break;
 a8c:	08 95       	ret
		
		case DIO_PORTC:               /** PORTC  **/
		*u8_a_val = get_bit(PINC , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
 a8e:	83 b3       	in	r24, 0x13	; 19
 a90:	90 e0       	ldi	r25, 0x00	; 0
 a92:	02 c0       	rjmp	.+4      	; 0xa98 <DIO_readpin+0x4e>
 a94:	95 95       	asr	r25
 a96:	87 95       	ror	r24
 a98:	6a 95       	dec	r22
 a9a:	e2 f7       	brpl	.-8      	; 0xa94 <DIO_readpin+0x4a>
 a9c:	81 70       	andi	r24, 0x01	; 1
 a9e:	83 bb       	out	0x13, r24	; 19
 aa0:	fa 01       	movw	r30, r20
 aa2:	80 83       	st	Z, r24
/* INPUT   : u8_a_portid , PINID , POINTER TO SET THE VALUE IN IT      */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_readpin(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t* u8_a_val)
{
	PinRead_t en_a_Pinstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 aa4:	80 e0       	ldi	r24, 0x00	; 0
		*u8_a_val = get_bit(PINB , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
		break;
		
		case DIO_PORTC:               /** PORTC  **/
		*u8_a_val = get_bit(PINC , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
		break;
 aa6:	08 95       	ret
		
		case DIO_PORTD:               /** PORTD  **/
		*u8_a_val = get_bit(PIND , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
 aa8:	80 b3       	in	r24, 0x10	; 16
 aaa:	90 e0       	ldi	r25, 0x00	; 0
 aac:	02 c0       	rjmp	.+4      	; 0xab2 <DIO_readpin+0x68>
 aae:	95 95       	asr	r25
 ab0:	87 95       	ror	r24
 ab2:	6a 95       	dec	r22
 ab4:	e2 f7       	brpl	.-8      	; 0xaae <DIO_readpin+0x64>
 ab6:	81 70       	andi	r24, 0x01	; 1
 ab8:	80 bb       	out	0x10, r24	; 16
 aba:	fa 01       	movw	r30, r20
 abc:	80 83       	st	Z, r24
/* INPUT   : u8_a_portid , PINID , POINTER TO SET THE VALUE IN IT      */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_readpin(uint8_t u8_a_portid , uint8_t u8_a_pinid , uint8_t* u8_a_val)
{
	PinRead_t en_a_Pinstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 abe:	80 e0       	ldi	r24, 0x00	; 0
		*u8_a_val = get_bit(PINC , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
		break;
		
		case DIO_PORTD:               /** PORTD  **/
		*u8_a_val = get_bit(PIND , u8_a_pinid); /** GET THE VALUE OF THE BIT **/
		break;
 ac0:	08 95       	ret
		
		default:
		en_a_Pinstate = NOT_VALID_READ ;  /** READ IS NOT VALID  **/
 ac2:	81 e0       	ldi	r24, 0x01	; 1
		break;
	} 
	
	return en_a_Pinstate ; /** RETURN THE FINAL STATE OF THE FUNCTION **/	
}
 ac4:	08 95       	ret

00000ac6 <DIO_togglepin>:
/******************************************************************/
PinRead_t DIO_togglepin(uint8_t u8_a_portid , uint8_t u8_a_pinid )
{
	PinRead_t en_a_Pinreadstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
	
	switch(u8_a_portid) /** SWITCH ON THE PORT ID **/
 ac6:	81 30       	cpi	r24, 0x01	; 1
 ac8:	91 f0       	breq	.+36     	; 0xaee <DIO_togglepin+0x28>
 aca:	28 f0       	brcs	.+10     	; 0xad6 <DIO_togglepin+0x10>
 acc:	82 30       	cpi	r24, 0x02	; 2
 ace:	d9 f0       	breq	.+54     	; 0xb06 <DIO_togglepin+0x40>
 ad0:	83 30       	cpi	r24, 0x03	; 3
 ad2:	29 f1       	breq	.+74     	; 0xb1e <DIO_togglepin+0x58>
 ad4:	30 c0       	rjmp	.+96     	; 0xb36 <DIO_togglepin+0x70>
	{
		case DIO_PORTA:
		toggle_bit(PORTA , u8_a_pinid);
 ad6:	2b b3       	in	r18, 0x1b	; 27
 ad8:	81 e0       	ldi	r24, 0x01	; 1
 ada:	90 e0       	ldi	r25, 0x00	; 0
 adc:	02 c0       	rjmp	.+4      	; 0xae2 <DIO_togglepin+0x1c>
 ade:	88 0f       	add	r24, r24
 ae0:	99 1f       	adc	r25, r25
 ae2:	6a 95       	dec	r22
 ae4:	e2 f7       	brpl	.-8      	; 0xade <DIO_togglepin+0x18>
 ae6:	82 27       	eor	r24, r18
 ae8:	8b bb       	out	0x1b, r24	; 27
/* INPUT   : u8_a_portid , PINID                                  */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_togglepin(uint8_t u8_a_portid , uint8_t u8_a_pinid )
{
	PinRead_t en_a_Pinreadstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 aea:	80 e0       	ldi	r24, 0x00	; 0
	
	switch(u8_a_portid) /** SWITCH ON THE PORT ID **/
	{
		case DIO_PORTA:
		toggle_bit(PORTA , u8_a_pinid);
		break;
 aec:	08 95       	ret
		
		case DIO_PORTB:
		toggle_bit(PORTB , u8_a_pinid);
 aee:	28 b3       	in	r18, 0x18	; 24
 af0:	81 e0       	ldi	r24, 0x01	; 1
 af2:	90 e0       	ldi	r25, 0x00	; 0
 af4:	02 c0       	rjmp	.+4      	; 0xafa <DIO_togglepin+0x34>
 af6:	88 0f       	add	r24, r24
 af8:	99 1f       	adc	r25, r25
 afa:	6a 95       	dec	r22
 afc:	e2 f7       	brpl	.-8      	; 0xaf6 <DIO_togglepin+0x30>
 afe:	82 27       	eor	r24, r18
 b00:	88 bb       	out	0x18, r24	; 24
/* INPUT   : u8_a_portid , PINID                                  */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_togglepin(uint8_t u8_a_portid , uint8_t u8_a_pinid )
{
	PinRead_t en_a_Pinreadstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 b02:	80 e0       	ldi	r24, 0x00	; 0
		toggle_bit(PORTA , u8_a_pinid);
		break;
		
		case DIO_PORTB:
		toggle_bit(PORTB , u8_a_pinid);
		break;
 b04:	08 95       	ret
		
		case DIO_PORTC:
		toggle_bit(PORTC , u8_a_pinid);
 b06:	25 b3       	in	r18, 0x15	; 21
 b08:	81 e0       	ldi	r24, 0x01	; 1
 b0a:	90 e0       	ldi	r25, 0x00	; 0
 b0c:	02 c0       	rjmp	.+4      	; 0xb12 <DIO_togglepin+0x4c>
 b0e:	88 0f       	add	r24, r24
 b10:	99 1f       	adc	r25, r25
 b12:	6a 95       	dec	r22
 b14:	e2 f7       	brpl	.-8      	; 0xb0e <DIO_togglepin+0x48>
 b16:	82 27       	eor	r24, r18
 b18:	85 bb       	out	0x15, r24	; 21
/* INPUT   : u8_a_portid , PINID                                  */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_togglepin(uint8_t u8_a_portid , uint8_t u8_a_pinid )
{
	PinRead_t en_a_Pinreadstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 b1a:	80 e0       	ldi	r24, 0x00	; 0
		toggle_bit(PORTB , u8_a_pinid);
		break;
		
		case DIO_PORTC:
		toggle_bit(PORTC , u8_a_pinid);
		break;
 b1c:	08 95       	ret
		
		case DIO_PORTD:
		toggle_bit(PORTD , u8_a_pinid);
 b1e:	22 b3       	in	r18, 0x12	; 18
 b20:	81 e0       	ldi	r24, 0x01	; 1
 b22:	90 e0       	ldi	r25, 0x00	; 0
 b24:	02 c0       	rjmp	.+4      	; 0xb2a <DIO_togglepin+0x64>
 b26:	88 0f       	add	r24, r24
 b28:	99 1f       	adc	r25, r25
 b2a:	6a 95       	dec	r22
 b2c:	e2 f7       	brpl	.-8      	; 0xb26 <DIO_togglepin+0x60>
 b2e:	82 27       	eor	r24, r18
 b30:	82 bb       	out	0x12, r24	; 18
/* INPUT   : u8_a_portid , PINID                                  */
/* RETURNS : PinRead_t                                            */
/******************************************************************/
PinRead_t DIO_togglepin(uint8_t u8_a_portid , uint8_t u8_a_pinid )
{
	PinRead_t en_a_Pinreadstate = VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
 b32:	80 e0       	ldi	r24, 0x00	; 0
		toggle_bit(PORTC , u8_a_pinid);
		break;
		
		case DIO_PORTD:
		toggle_bit(PORTD , u8_a_pinid);
		break;
 b34:	08 95       	ret
		
		default:
		/** DO NOTHING **/
		en_a_Pinreadstate = NOT_VALID_READ ; /** RETURN AN ERROR **/
 b36:	81 e0       	ldi	r24, 0x01	; 1
		break;
	} 
	
	return en_a_Pinreadstate ; /** RETURN THE FINAL STATE OF THE FUNCTION **/
}
 b38:	08 95       	ret

00000b3a <SPI_initslave>:
	{
		SPI_sendbyte(u8_a_str[u8_L_counter]); /** SEND CHARACTER **/
		
		u8_L_counter++; /* MOVE TO THE SECOND LETTER */
	}
}
 b3a:	40 e0       	ldi	r20, 0x00	; 0
 b3c:	64 e0       	ldi	r22, 0x04	; 4
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
 b44:	40 e0       	ldi	r20, 0x00	; 0
 b46:	65 e0       	ldi	r22, 0x05	; 5
 b48:	81 e0       	ldi	r24, 0x01	; 1
 b4a:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
 b4e:	41 e0       	ldi	r20, 0x01	; 1
 b50:	66 e0       	ldi	r22, 0x06	; 6
 b52:	81 e0       	ldi	r24, 0x01	; 1
 b54:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
 b58:	40 e0       	ldi	r20, 0x00	; 0
 b5a:	67 e0       	ldi	r22, 0x07	; 7
 b5c:	81 e0       	ldi	r24, 0x01	; 1
 b5e:	0e 94 27 04 	call	0x84e	; 0x84e <DIO_setpindir>
 b62:	8d b1       	in	r24, 0x0d	; 13
 b64:	80 64       	ori	r24, 0x40	; 64
 b66:	8d b9       	out	0x0d, r24	; 13
 b68:	8d b1       	in	r24, 0x0d	; 13
 b6a:	8f 7e       	andi	r24, 0xEF	; 239
 b6c:	8d b9       	out	0x0d, r24	; 13
 b6e:	8d b1       	in	r24, 0x0d	; 13
 b70:	87 7f       	andi	r24, 0xF7	; 247
 b72:	8d b9       	out	0x0d, r24	; 13
 b74:	8d b1       	in	r24, 0x0d	; 13
 b76:	8b 7f       	andi	r24, 0xFB	; 251
 b78:	8d b9       	out	0x0d, r24	; 13
 b7a:	08 95       	ret

00000b7c <SPI_receivebyte>:
 b7c:	77 9b       	sbis	0x0e, 7	; 14
 b7e:	fe cf       	rjmp	.-4      	; 0xb7c <SPI_receivebyte>
 b80:	2f b1       	in	r18, 0x0f	; 15
 b82:	fc 01       	movw	r30, r24
 b84:	20 83       	st	Z, r18
 b86:	08 95       	ret

00000b88 <SPI_receivestring>:
/** FUNCTION FOR MASTER TO SEND STRING                          **/
/** ARGUMENTS  : u8_a_str (string)                              **/
/** RETURNS    : en_a_spierrstatus                              **/
/*****************************************************************/
en_a_spierrstatus SPI_receivestring(uint8_t * u8_a_str)
{
 b88:	0f 93       	push	r16
 b8a:	1f 93       	push	r17
 b8c:	cf 93       	push	r28
 b8e:	8c 01       	movw	r16, r24
	uint8_t u8_L_counter = 0 ; /** COUNTER FOR STRING LETTERS **/
 b90:	c0 e0       	ldi	r28, 0x00	; 0
	
	//str[counter] = SPI_RECEIVE_BYTE();
	
	while (u8_a_str[u8_L_counter] != '\0')
 b92:	03 c0       	rjmp	.+6      	; 0xb9a <SPI_receivestring+0x12>
	{
		SPI_receivebyte(&u8_a_str[u8_L_counter]); /** RECEIVE CHARACTER **/
 b94:	0e 94 be 05 	call	0xb7c	; 0xb7c <SPI_receivebyte>
		
		u8_L_counter++ ; /* MOVE TO THE SECOND LETTER */
 b98:	cf 5f       	subi	r28, 0xFF	; 255
{
	uint8_t u8_L_counter = 0 ; /** COUNTER FOR STRING LETTERS **/
	
	//str[counter] = SPI_RECEIVE_BYTE();
	
	while (u8_a_str[u8_L_counter] != '\0')
 b9a:	c8 01       	movw	r24, r16
 b9c:	8c 0f       	add	r24, r28
 b9e:	91 1d       	adc	r25, r1
 ba0:	fc 01       	movw	r30, r24
 ba2:	20 81       	ld	r18, Z
 ba4:	21 11       	cpse	r18, r1
 ba6:	f6 cf       	rjmp	.-20     	; 0xb94 <SPI_receivestring+0xc>
		
		u8_L_counter++ ; /* MOVE TO THE SECOND LETTER */
	}
	
	
	u8_a_str[u8_L_counter] = '\0' ; /* TERMINATOR OF STRING */
 ba8:	10 82       	st	Z, r1
}
 baa:	cf 91       	pop	r28
 bac:	1f 91       	pop	r17
 bae:	0f 91       	pop	r16
 bb0:	08 95       	ret

00000bb2 <TMR0_init>:
	 /* TIMER MODE OF TMR0 */
	#elif TIMER0_CLK_SRC == INTERNAL_CLK_SRC
	
	 #if TIMER0_MODE == TMR0_NORMAL_MODE
	 
	 clear_bit(TCCR0 , 7);
 bb2:	83 b7       	in	r24, 0x33	; 51
 bb4:	8f 77       	andi	r24, 0x7F	; 127
 bb6:	83 bf       	out	0x33, r24	; 51
	 clear_bit(TCCR0 , 6);
 bb8:	83 b7       	in	r24, 0x33	; 51
 bba:	8f 7b       	andi	r24, 0xBF	; 191
 bbc:	83 bf       	out	0x33, r24	; 51
	 clear_bit(TCCR0 , 3);
 bbe:	83 b7       	in	r24, 0x33	; 51
 bc0:	87 7f       	andi	r24, 0xF7	; 247
 bc2:	83 bf       	out	0x33, r24	; 51
	 clear_bit(TCCR0 , 4);
 bc4:	83 b7       	in	r24, 0x33	; 51
 bc6:	8f 7e       	andi	r24, 0xEF	; 239
 bc8:	83 bf       	out	0x33, r24	; 51
	 clear_bit(TCCR0 , 5);
 bca:	83 b7       	in	r24, 0x33	; 51
 bcc:	8f 7d       	andi	r24, 0xDF	; 223
 bce:	83 bf       	out	0x33, r24	; 51
	  #endif
	 #endif
	#endif
	
	return en_a_initstatus ; /** RETURN THE STATUS OF INITIALIZATION **/
}
 bd0:	80 e0       	ldi	r24, 0x00	; 0
 bd2:	08 95       	ret

00000bd4 <TMR0_start>:
{
	TMR0_start_error en_a_startstatus = VALID_START ; /** VARIABLE TO RETURN THE STATUS OF START **/
	
	#if TIMER0_PRESCALER_VAL == PRESCALER_1024
	
	set_bit(TCCR0 , 0);
 bd4:	83 b7       	in	r24, 0x33	; 51
 bd6:	81 60       	ori	r24, 0x01	; 1
 bd8:	83 bf       	out	0x33, r24	; 51
	clear_bit(TCCR0 , 1);
 bda:	83 b7       	in	r24, 0x33	; 51
 bdc:	8d 7f       	andi	r24, 0xFD	; 253
 bde:	83 bf       	out	0x33, r24	; 51
	set_bit(TCCR0 , 2);
 be0:	83 b7       	in	r24, 0x33	; 51
 be2:	84 60       	ori	r24, 0x04	; 4
 be4:	83 bf       	out	0x33, r24	; 51
	en_a_startstatus = VALID_START ; /** START DONE PROBERLY **/
	
	#endif
	
	return en_a_startstatus ; /** RETURN THE STATUS **/
}
 be6:	80 e0       	ldi	r24, 0x00	; 0
 be8:	08 95       	ret

00000bea <TMR0_stop>:
TMR0_stop_error TMR0_stop(void)
{
	TMR0_stop_error en_a_stopStatus = VALID_STOP ; /** VARIABLE TO RETURN THE STATUS **/
	
	/** SET CONFIGURATIONS AS NO CLOCK SOURCE **/
	clear_bit(TCCR0 , 0);
 bea:	83 b7       	in	r24, 0x33	; 51
 bec:	8e 7f       	andi	r24, 0xFE	; 254
 bee:	83 bf       	out	0x33, r24	; 51
	clear_bit(TCCR0 , 1);
 bf0:	83 b7       	in	r24, 0x33	; 51
 bf2:	8d 7f       	andi	r24, 0xFD	; 253
 bf4:	83 bf       	out	0x33, r24	; 51
	clear_bit(TCCR0 , 2);
 bf6:	83 b7       	in	r24, 0x33	; 51
 bf8:	8b 7f       	andi	r24, 0xFB	; 251
 bfa:	83 bf       	out	0x33, r24	; 51
	
	en_a_stopStatus = VALID_STOP ; /** STOP DONE PROPERLY **/
	
	return en_a_stopStatus ; /** RETURN THE STATUS **/
	
}
 bfc:	80 e0       	ldi	r24, 0x00	; 0
 bfe:	08 95       	ret

00000c00 <TMR0_delayms>:
	/******************************************************************************************/
	/**               THIS CALCULATIONS CONFIGURED AS F_CPU   16 MHZ                         **/
	/******************************************************************************************/
	#if TIMER0_PRESCALER_VAL == PRESCALER_1024  /** CHECK THE PRESCALLER FROM CONFIG FILE **/
	 
        u32_gs_tmr0nuofovs = (u32_a_delayms / 16.384);   /** CALCULATING NUMBER OF OVERFLOWS ( DESIRED DELAY / TIME OF OVER FLOW ) **/ 
 c00:	0e 94 dd 06 	call	0xdba	; 0xdba <__floatunsisf>
 c04:	2f e6       	ldi	r18, 0x6F	; 111
 c06:	32 e1       	ldi	r19, 0x12	; 18
 c08:	43 e8       	ldi	r20, 0x83	; 131
 c0a:	51 e4       	ldi	r21, 0x41	; 65
 c0c:	0e 94 3c 06 	call	0xc78	; 0xc78 <__divsf3>
 c10:	0e 94 ae 06 	call	0xd5c	; 0xd5c <__fixunssfsi>
 c14:	60 93 f8 00 	sts	0x00F8, r22	; 0x8000f8 <u32_gs_tmr0nuofovs>
 c18:	70 93 f9 00 	sts	0x00F9, r23	; 0x8000f9 <u32_gs_tmr0nuofovs+0x1>
 c1c:	80 93 fa 00 	sts	0x00FA, r24	; 0x8000fa <u32_gs_tmr0nuofovs+0x2>
 c20:	90 93 fb 00 	sts	0x00FB, r25	; 0x8000fb <u32_gs_tmr0nuofovs+0x3>
	
        TCNT0 = 0 ;   /** SET THE INITIAL VALUE IN TCNT0 REGISTER **/
 c24:	12 be       	out	0x32, r1	; 50
	
	    en_a_delaystatus = VALID_DELAY ; /** VALID DELAY CONFIGURATIN **/
	
	#endif
	
	TMR0_start(); /** START TMR0 PRESCALLER **/
 c26:	0e 94 ea 05 	call	0xbd4	; 0xbd4 <TMR0_start>
/** RETURNS    : TMR0_delay                                                    */
/*******************************************************************************/
TMR0_delay_error TMR0_delayms(uint32_t u32_a_delayms)
{
	
	uint32_t u32_a_overflowcounter = 0 ;
 c2a:	40 e0       	ldi	r20, 0x00	; 0
 c2c:	50 e0       	ldi	r21, 0x00	; 0
 c2e:	ba 01       	movw	r22, r20
	
	#endif
	
	TMR0_start(); /** START TMR0 PRESCALLER **/
	
	while ( u32_a_overflowcounter < u32_gs_tmr0nuofovs ) /** STUCK IN THIS LOOP UNTILL THIS CONDITION IS FALSE **/
 c30:	0a c0       	rjmp	.+20     	; 0xc46 <TMR0_delayms+0x46>
	{
		while((TIFR & (1 << 0)) == 0); /** DO NOTHING UNTILL THIS FLAG RAISED (OVERFLOW HAPPENED) **/
 c32:	08 b6       	in	r0, 0x38	; 56
 c34:	00 fe       	sbrs	r0, 0
 c36:	fd cf       	rjmp	.-6      	; 0xc32 <TMR0_delayms+0x32>
		
		set_bit(TIFR , 0);        /** CLEAR THE FLAG BY SOFTWARE **/
 c38:	88 b7       	in	r24, 0x38	; 56
 c3a:	81 60       	ori	r24, 0x01	; 1
 c3c:	88 bf       	out	0x38, r24	; 56
		
		u32_a_overflowcounter++ ; /** INCREASE THE OVERFLOWS BY ONE **/
 c3e:	4f 5f       	subi	r20, 0xFF	; 255
 c40:	5f 4f       	sbci	r21, 0xFF	; 255
 c42:	6f 4f       	sbci	r22, 0xFF	; 255
 c44:	7f 4f       	sbci	r23, 0xFF	; 255
	
	#endif
	
	TMR0_start(); /** START TMR0 PRESCALLER **/
	
	while ( u32_a_overflowcounter < u32_gs_tmr0nuofovs ) /** STUCK IN THIS LOOP UNTILL THIS CONDITION IS FALSE **/
 c46:	80 91 f8 00 	lds	r24, 0x00F8	; 0x8000f8 <u32_gs_tmr0nuofovs>
 c4a:	90 91 f9 00 	lds	r25, 0x00F9	; 0x8000f9 <u32_gs_tmr0nuofovs+0x1>
 c4e:	a0 91 fa 00 	lds	r26, 0x00FA	; 0x8000fa <u32_gs_tmr0nuofovs+0x2>
 c52:	b0 91 fb 00 	lds	r27, 0x00FB	; 0x8000fb <u32_gs_tmr0nuofovs+0x3>
 c56:	48 17       	cp	r20, r24
 c58:	59 07       	cpc	r21, r25
 c5a:	6a 07       	cpc	r22, r26
 c5c:	7b 07       	cpc	r23, r27
 c5e:	48 f3       	brcs	.-46     	; 0xc32 <TMR0_delayms+0x32>
		set_bit(TIFR , 0);        /** CLEAR THE FLAG BY SOFTWARE **/
		
		u32_a_overflowcounter++ ; /** INCREASE THE OVERFLOWS BY ONE **/
	}
	
	u32_gs_tmr0nuofovs = 0 ; /** REINTIALIZE THE OVERFLOWS COUNTER TO 0 AGAIN **/
 c60:	10 92 f8 00 	sts	0x00F8, r1	; 0x8000f8 <u32_gs_tmr0nuofovs>
 c64:	10 92 f9 00 	sts	0x00F9, r1	; 0x8000f9 <u32_gs_tmr0nuofovs+0x1>
 c68:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <u32_gs_tmr0nuofovs+0x2>
 c6c:	10 92 fb 00 	sts	0x00FB, r1	; 0x8000fb <u32_gs_tmr0nuofovs+0x3>

	TMR0_stop();   /** STOP TMR0 TOSTART FROM 0 WHEN IT CALLED AGAIN **/
 c70:	0e 94 f5 05 	call	0xbea	; 0xbea <TMR0_stop>
	
	return en_a_delaystatus ; /** RETURN THE STATUS **/
}
 c74:	80 e0       	ldi	r24, 0x00	; 0
 c76:	08 95       	ret

00000c78 <__divsf3>:
 c78:	0e 94 50 06 	call	0xca0	; 0xca0 <__divsf3x>
 c7c:	0c 94 31 07 	jmp	0xe62	; 0xe62 <__fp_round>
 c80:	0e 94 2a 07 	call	0xe54	; 0xe54 <__fp_pscB>
 c84:	58 f0       	brcs	.+22     	; 0xc9c <__divsf3+0x24>
 c86:	0e 94 23 07 	call	0xe46	; 0xe46 <__fp_pscA>
 c8a:	40 f0       	brcs	.+16     	; 0xc9c <__divsf3+0x24>
 c8c:	29 f4       	brne	.+10     	; 0xc98 <__divsf3+0x20>
 c8e:	5f 3f       	cpi	r21, 0xFF	; 255
 c90:	29 f0       	breq	.+10     	; 0xc9c <__divsf3+0x24>
 c92:	0c 94 1a 07 	jmp	0xe34	; 0xe34 <__fp_inf>
 c96:	51 11       	cpse	r21, r1
 c98:	0c 94 65 07 	jmp	0xeca	; 0xeca <__fp_szero>
 c9c:	0c 94 20 07 	jmp	0xe40	; 0xe40 <__fp_nan>

00000ca0 <__divsf3x>:
 ca0:	0e 94 42 07 	call	0xe84	; 0xe84 <__fp_split3>
 ca4:	68 f3       	brcs	.-38     	; 0xc80 <__divsf3+0x8>

00000ca6 <__divsf3_pse>:
 ca6:	99 23       	and	r25, r25
 ca8:	b1 f3       	breq	.-20     	; 0xc96 <__divsf3+0x1e>
 caa:	55 23       	and	r21, r21
 cac:	91 f3       	breq	.-28     	; 0xc92 <__divsf3+0x1a>
 cae:	95 1b       	sub	r25, r21
 cb0:	55 0b       	sbc	r21, r21
 cb2:	bb 27       	eor	r27, r27
 cb4:	aa 27       	eor	r26, r26
 cb6:	62 17       	cp	r22, r18
 cb8:	73 07       	cpc	r23, r19
 cba:	84 07       	cpc	r24, r20
 cbc:	38 f0       	brcs	.+14     	; 0xccc <__divsf3_pse+0x26>
 cbe:	9f 5f       	subi	r25, 0xFF	; 255
 cc0:	5f 4f       	sbci	r21, 0xFF	; 255
 cc2:	22 0f       	add	r18, r18
 cc4:	33 1f       	adc	r19, r19
 cc6:	44 1f       	adc	r20, r20
 cc8:	aa 1f       	adc	r26, r26
 cca:	a9 f3       	breq	.-22     	; 0xcb6 <__divsf3_pse+0x10>
 ccc:	35 d0       	rcall	.+106    	; 0xd38 <__divsf3_pse+0x92>
 cce:	0e 2e       	mov	r0, r30
 cd0:	3a f0       	brmi	.+14     	; 0xce0 <__divsf3_pse+0x3a>
 cd2:	e0 e8       	ldi	r30, 0x80	; 128
 cd4:	32 d0       	rcall	.+100    	; 0xd3a <__divsf3_pse+0x94>
 cd6:	91 50       	subi	r25, 0x01	; 1
 cd8:	50 40       	sbci	r21, 0x00	; 0
 cda:	e6 95       	lsr	r30
 cdc:	00 1c       	adc	r0, r0
 cde:	ca f7       	brpl	.-14     	; 0xcd2 <__divsf3_pse+0x2c>
 ce0:	2b d0       	rcall	.+86     	; 0xd38 <__divsf3_pse+0x92>
 ce2:	fe 2f       	mov	r31, r30
 ce4:	29 d0       	rcall	.+82     	; 0xd38 <__divsf3_pse+0x92>
 ce6:	66 0f       	add	r22, r22
 ce8:	77 1f       	adc	r23, r23
 cea:	88 1f       	adc	r24, r24
 cec:	bb 1f       	adc	r27, r27
 cee:	26 17       	cp	r18, r22
 cf0:	37 07       	cpc	r19, r23
 cf2:	48 07       	cpc	r20, r24
 cf4:	ab 07       	cpc	r26, r27
 cf6:	b0 e8       	ldi	r27, 0x80	; 128
 cf8:	09 f0       	breq	.+2      	; 0xcfc <__divsf3_pse+0x56>
 cfa:	bb 0b       	sbc	r27, r27
 cfc:	80 2d       	mov	r24, r0
 cfe:	bf 01       	movw	r22, r30
 d00:	ff 27       	eor	r31, r31
 d02:	93 58       	subi	r25, 0x83	; 131
 d04:	5f 4f       	sbci	r21, 0xFF	; 255
 d06:	3a f0       	brmi	.+14     	; 0xd16 <__divsf3_pse+0x70>
 d08:	9e 3f       	cpi	r25, 0xFE	; 254
 d0a:	51 05       	cpc	r21, r1
 d0c:	78 f0       	brcs	.+30     	; 0xd2c <__divsf3_pse+0x86>
 d0e:	0c 94 1a 07 	jmp	0xe34	; 0xe34 <__fp_inf>
 d12:	0c 94 65 07 	jmp	0xeca	; 0xeca <__fp_szero>
 d16:	5f 3f       	cpi	r21, 0xFF	; 255
 d18:	e4 f3       	brlt	.-8      	; 0xd12 <__divsf3_pse+0x6c>
 d1a:	98 3e       	cpi	r25, 0xE8	; 232
 d1c:	d4 f3       	brlt	.-12     	; 0xd12 <__divsf3_pse+0x6c>
 d1e:	86 95       	lsr	r24
 d20:	77 95       	ror	r23
 d22:	67 95       	ror	r22
 d24:	b7 95       	ror	r27
 d26:	f7 95       	ror	r31
 d28:	9f 5f       	subi	r25, 0xFF	; 255
 d2a:	c9 f7       	brne	.-14     	; 0xd1e <__divsf3_pse+0x78>
 d2c:	88 0f       	add	r24, r24
 d2e:	91 1d       	adc	r25, r1
 d30:	96 95       	lsr	r25
 d32:	87 95       	ror	r24
 d34:	97 f9       	bld	r25, 7
 d36:	08 95       	ret
 d38:	e1 e0       	ldi	r30, 0x01	; 1
 d3a:	66 0f       	add	r22, r22
 d3c:	77 1f       	adc	r23, r23
 d3e:	88 1f       	adc	r24, r24
 d40:	bb 1f       	adc	r27, r27
 d42:	62 17       	cp	r22, r18
 d44:	73 07       	cpc	r23, r19
 d46:	84 07       	cpc	r24, r20
 d48:	ba 07       	cpc	r27, r26
 d4a:	20 f0       	brcs	.+8      	; 0xd54 <__divsf3_pse+0xae>
 d4c:	62 1b       	sub	r22, r18
 d4e:	73 0b       	sbc	r23, r19
 d50:	84 0b       	sbc	r24, r20
 d52:	ba 0b       	sbc	r27, r26
 d54:	ee 1f       	adc	r30, r30
 d56:	88 f7       	brcc	.-30     	; 0xd3a <__divsf3_pse+0x94>
 d58:	e0 95       	com	r30
 d5a:	08 95       	ret

00000d5c <__fixunssfsi>:
 d5c:	0e 94 4a 07 	call	0xe94	; 0xe94 <__fp_splitA>
 d60:	88 f0       	brcs	.+34     	; 0xd84 <__fixunssfsi+0x28>
 d62:	9f 57       	subi	r25, 0x7F	; 127
 d64:	98 f0       	brcs	.+38     	; 0xd8c <__fixunssfsi+0x30>
 d66:	b9 2f       	mov	r27, r25
 d68:	99 27       	eor	r25, r25
 d6a:	b7 51       	subi	r27, 0x17	; 23
 d6c:	b0 f0       	brcs	.+44     	; 0xd9a <__fixunssfsi+0x3e>
 d6e:	e1 f0       	breq	.+56     	; 0xda8 <__fixunssfsi+0x4c>
 d70:	66 0f       	add	r22, r22
 d72:	77 1f       	adc	r23, r23
 d74:	88 1f       	adc	r24, r24
 d76:	99 1f       	adc	r25, r25
 d78:	1a f0       	brmi	.+6      	; 0xd80 <__fixunssfsi+0x24>
 d7a:	ba 95       	dec	r27
 d7c:	c9 f7       	brne	.-14     	; 0xd70 <__fixunssfsi+0x14>
 d7e:	14 c0       	rjmp	.+40     	; 0xda8 <__fixunssfsi+0x4c>
 d80:	b1 30       	cpi	r27, 0x01	; 1
 d82:	91 f0       	breq	.+36     	; 0xda8 <__fixunssfsi+0x4c>
 d84:	0e 94 64 07 	call	0xec8	; 0xec8 <__fp_zero>
 d88:	b1 e0       	ldi	r27, 0x01	; 1
 d8a:	08 95       	ret
 d8c:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_zero>
 d90:	67 2f       	mov	r22, r23
 d92:	78 2f       	mov	r23, r24
 d94:	88 27       	eor	r24, r24
 d96:	b8 5f       	subi	r27, 0xF8	; 248
 d98:	39 f0       	breq	.+14     	; 0xda8 <__fixunssfsi+0x4c>
 d9a:	b9 3f       	cpi	r27, 0xF9	; 249
 d9c:	cc f3       	brlt	.-14     	; 0xd90 <__fixunssfsi+0x34>
 d9e:	86 95       	lsr	r24
 da0:	77 95       	ror	r23
 da2:	67 95       	ror	r22
 da4:	b3 95       	inc	r27
 da6:	d9 f7       	brne	.-10     	; 0xd9e <__fixunssfsi+0x42>
 da8:	3e f4       	brtc	.+14     	; 0xdb8 <__fixunssfsi+0x5c>
 daa:	90 95       	com	r25
 dac:	80 95       	com	r24
 dae:	70 95       	com	r23
 db0:	61 95       	neg	r22
 db2:	7f 4f       	sbci	r23, 0xFF	; 255
 db4:	8f 4f       	sbci	r24, 0xFF	; 255
 db6:	9f 4f       	sbci	r25, 0xFF	; 255
 db8:	08 95       	ret

00000dba <__floatunsisf>:
 dba:	e8 94       	clt
 dbc:	09 c0       	rjmp	.+18     	; 0xdd0 <__floatsisf+0x12>

00000dbe <__floatsisf>:
 dbe:	97 fb       	bst	r25, 7
 dc0:	3e f4       	brtc	.+14     	; 0xdd0 <__floatsisf+0x12>
 dc2:	90 95       	com	r25
 dc4:	80 95       	com	r24
 dc6:	70 95       	com	r23
 dc8:	61 95       	neg	r22
 dca:	7f 4f       	sbci	r23, 0xFF	; 255
 dcc:	8f 4f       	sbci	r24, 0xFF	; 255
 dce:	9f 4f       	sbci	r25, 0xFF	; 255
 dd0:	99 23       	and	r25, r25
 dd2:	a9 f0       	breq	.+42     	; 0xdfe <__floatsisf+0x40>
 dd4:	f9 2f       	mov	r31, r25
 dd6:	96 e9       	ldi	r25, 0x96	; 150
 dd8:	bb 27       	eor	r27, r27
 dda:	93 95       	inc	r25
 ddc:	f6 95       	lsr	r31
 dde:	87 95       	ror	r24
 de0:	77 95       	ror	r23
 de2:	67 95       	ror	r22
 de4:	b7 95       	ror	r27
 de6:	f1 11       	cpse	r31, r1
 de8:	f8 cf       	rjmp	.-16     	; 0xdda <__floatsisf+0x1c>
 dea:	fa f4       	brpl	.+62     	; 0xe2a <__floatsisf+0x6c>
 dec:	bb 0f       	add	r27, r27
 dee:	11 f4       	brne	.+4      	; 0xdf4 <__floatsisf+0x36>
 df0:	60 ff       	sbrs	r22, 0
 df2:	1b c0       	rjmp	.+54     	; 0xe2a <__floatsisf+0x6c>
 df4:	6f 5f       	subi	r22, 0xFF	; 255
 df6:	7f 4f       	sbci	r23, 0xFF	; 255
 df8:	8f 4f       	sbci	r24, 0xFF	; 255
 dfa:	9f 4f       	sbci	r25, 0xFF	; 255
 dfc:	16 c0       	rjmp	.+44     	; 0xe2a <__floatsisf+0x6c>
 dfe:	88 23       	and	r24, r24
 e00:	11 f0       	breq	.+4      	; 0xe06 <__floatsisf+0x48>
 e02:	96 e9       	ldi	r25, 0x96	; 150
 e04:	11 c0       	rjmp	.+34     	; 0xe28 <__floatsisf+0x6a>
 e06:	77 23       	and	r23, r23
 e08:	21 f0       	breq	.+8      	; 0xe12 <__floatsisf+0x54>
 e0a:	9e e8       	ldi	r25, 0x8E	; 142
 e0c:	87 2f       	mov	r24, r23
 e0e:	76 2f       	mov	r23, r22
 e10:	05 c0       	rjmp	.+10     	; 0xe1c <__floatsisf+0x5e>
 e12:	66 23       	and	r22, r22
 e14:	71 f0       	breq	.+28     	; 0xe32 <__floatsisf+0x74>
 e16:	96 e8       	ldi	r25, 0x86	; 134
 e18:	86 2f       	mov	r24, r22
 e1a:	70 e0       	ldi	r23, 0x00	; 0
 e1c:	60 e0       	ldi	r22, 0x00	; 0
 e1e:	2a f0       	brmi	.+10     	; 0xe2a <__floatsisf+0x6c>
 e20:	9a 95       	dec	r25
 e22:	66 0f       	add	r22, r22
 e24:	77 1f       	adc	r23, r23
 e26:	88 1f       	adc	r24, r24
 e28:	da f7       	brpl	.-10     	; 0xe20 <__floatsisf+0x62>
 e2a:	88 0f       	add	r24, r24
 e2c:	96 95       	lsr	r25
 e2e:	87 95       	ror	r24
 e30:	97 f9       	bld	r25, 7
 e32:	08 95       	ret

00000e34 <__fp_inf>:
 e34:	97 f9       	bld	r25, 7
 e36:	9f 67       	ori	r25, 0x7F	; 127
 e38:	80 e8       	ldi	r24, 0x80	; 128
 e3a:	70 e0       	ldi	r23, 0x00	; 0
 e3c:	60 e0       	ldi	r22, 0x00	; 0
 e3e:	08 95       	ret

00000e40 <__fp_nan>:
 e40:	9f ef       	ldi	r25, 0xFF	; 255
 e42:	80 ec       	ldi	r24, 0xC0	; 192
 e44:	08 95       	ret

00000e46 <__fp_pscA>:
 e46:	00 24       	eor	r0, r0
 e48:	0a 94       	dec	r0
 e4a:	16 16       	cp	r1, r22
 e4c:	17 06       	cpc	r1, r23
 e4e:	18 06       	cpc	r1, r24
 e50:	09 06       	cpc	r0, r25
 e52:	08 95       	ret

00000e54 <__fp_pscB>:
 e54:	00 24       	eor	r0, r0
 e56:	0a 94       	dec	r0
 e58:	12 16       	cp	r1, r18
 e5a:	13 06       	cpc	r1, r19
 e5c:	14 06       	cpc	r1, r20
 e5e:	05 06       	cpc	r0, r21
 e60:	08 95       	ret

00000e62 <__fp_round>:
 e62:	09 2e       	mov	r0, r25
 e64:	03 94       	inc	r0
 e66:	00 0c       	add	r0, r0
 e68:	11 f4       	brne	.+4      	; 0xe6e <__fp_round+0xc>
 e6a:	88 23       	and	r24, r24
 e6c:	52 f0       	brmi	.+20     	; 0xe82 <__fp_round+0x20>
 e6e:	bb 0f       	add	r27, r27
 e70:	40 f4       	brcc	.+16     	; 0xe82 <__fp_round+0x20>
 e72:	bf 2b       	or	r27, r31
 e74:	11 f4       	brne	.+4      	; 0xe7a <__fp_round+0x18>
 e76:	60 ff       	sbrs	r22, 0
 e78:	04 c0       	rjmp	.+8      	; 0xe82 <__fp_round+0x20>
 e7a:	6f 5f       	subi	r22, 0xFF	; 255
 e7c:	7f 4f       	sbci	r23, 0xFF	; 255
 e7e:	8f 4f       	sbci	r24, 0xFF	; 255
 e80:	9f 4f       	sbci	r25, 0xFF	; 255
 e82:	08 95       	ret

00000e84 <__fp_split3>:
 e84:	57 fd       	sbrc	r21, 7
 e86:	90 58       	subi	r25, 0x80	; 128
 e88:	44 0f       	add	r20, r20
 e8a:	55 1f       	adc	r21, r21
 e8c:	59 f0       	breq	.+22     	; 0xea4 <__fp_splitA+0x10>
 e8e:	5f 3f       	cpi	r21, 0xFF	; 255
 e90:	71 f0       	breq	.+28     	; 0xeae <__fp_splitA+0x1a>
 e92:	47 95       	ror	r20

00000e94 <__fp_splitA>:
 e94:	88 0f       	add	r24, r24
 e96:	97 fb       	bst	r25, 7
 e98:	99 1f       	adc	r25, r25
 e9a:	61 f0       	breq	.+24     	; 0xeb4 <__fp_splitA+0x20>
 e9c:	9f 3f       	cpi	r25, 0xFF	; 255
 e9e:	79 f0       	breq	.+30     	; 0xebe <__fp_splitA+0x2a>
 ea0:	87 95       	ror	r24
 ea2:	08 95       	ret
 ea4:	12 16       	cp	r1, r18
 ea6:	13 06       	cpc	r1, r19
 ea8:	14 06       	cpc	r1, r20
 eaa:	55 1f       	adc	r21, r21
 eac:	f2 cf       	rjmp	.-28     	; 0xe92 <__fp_split3+0xe>
 eae:	46 95       	lsr	r20
 eb0:	f1 df       	rcall	.-30     	; 0xe94 <__fp_splitA>
 eb2:	08 c0       	rjmp	.+16     	; 0xec4 <__fp_splitA+0x30>
 eb4:	16 16       	cp	r1, r22
 eb6:	17 06       	cpc	r1, r23
 eb8:	18 06       	cpc	r1, r24
 eba:	99 1f       	adc	r25, r25
 ebc:	f1 cf       	rjmp	.-30     	; 0xea0 <__fp_splitA+0xc>
 ebe:	86 95       	lsr	r24
 ec0:	71 05       	cpc	r23, r1
 ec2:	61 05       	cpc	r22, r1
 ec4:	08 94       	sec
 ec6:	08 95       	ret

00000ec8 <__fp_zero>:
 ec8:	e8 94       	clt

00000eca <__fp_szero>:
 eca:	bb 27       	eor	r27, r27
 ecc:	66 27       	eor	r22, r22
 ece:	77 27       	eor	r23, r23
 ed0:	cb 01       	movw	r24, r22
 ed2:	97 f9       	bld	r25, 7
 ed4:	08 95       	ret

00000ed6 <__umulhisi3>:
 ed6:	a2 9f       	mul	r26, r18
 ed8:	b0 01       	movw	r22, r0
 eda:	b3 9f       	mul	r27, r19
 edc:	c0 01       	movw	r24, r0
 ede:	a3 9f       	mul	r26, r19
 ee0:	70 0d       	add	r23, r0
 ee2:	81 1d       	adc	r24, r1
 ee4:	11 24       	eor	r1, r1
 ee6:	91 1d       	adc	r25, r1
 ee8:	b2 9f       	mul	r27, r18
 eea:	70 0d       	add	r23, r0
 eec:	81 1d       	adc	r24, r1
 eee:	11 24       	eor	r1, r1
 ef0:	91 1d       	adc	r25, r1
 ef2:	08 95       	ret

00000ef4 <strcmp>:
 ef4:	fb 01       	movw	r30, r22
 ef6:	dc 01       	movw	r26, r24
 ef8:	8d 91       	ld	r24, X+
 efa:	01 90       	ld	r0, Z+
 efc:	80 19       	sub	r24, r0
 efe:	01 10       	cpse	r0, r1
 f00:	d9 f3       	breq	.-10     	; 0xef8 <strcmp+0x4>
 f02:	99 0b       	sbc	r25, r25
 f04:	08 95       	ret

00000f06 <_exit>:
 f06:	f8 94       	cli

00000f08 <__stop_program>:
 f08:	ff cf       	rjmp	.-2      	; 0xf08 <__stop_program>
